/*
MIT License

Copyright (c) 2016-2017 Alexander Korshun and the ACSUtils contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

ACSUtils uses code from ACS-X:	
	
	Copyright Ben Moir 2016
	Distributed under the Boost Software License, Version 1.0.

	Boost Software License - Version 1.0 - August 17th, 2003

	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:

	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.
*/

#library "bcsutils"
#import "zcommon.bcs"

#nocompact

// ZDoom does not allow to use more than 128 map variables in a single library.
// To reduce the amount of map variables ACSUtils use, all simple globals
// have been put into an array.
strict namespace BCSUtils {
enum : int { ACSUTILS_VERSION_MAJOR = 1 };
enum : int { ACSUTILS_VERSION_MINOR = 8 };
enum : int { ACSUTILS_VERSION_PATCH = 2 };

function str ACSUtilsVersion(void)
{
	return StrParam(
		d:ACSUTILS_VERSION_MAJOR, s:".",
		d:ACSUTILS_VERSION_MINOR, s:".",
		d:ACSUTILS_VERSION_PATCH
	);
}

// Multiple return values.
raw r1, r2, r3, r4, r5, r6, r7, r8;

enum : fixed { HUDTIC = 0.03 };
enum : fixed { HUD_STAYTIME_FOREVER = (fixed)(-1) };

enum : int { HUD_BLENDSTYLE_NORMAL = 0 };
enum : int { HUD_BLENDSTYLE_ADDITIVE = 1 };

enum : int { HUD_ALIGN_CENTER = 0 };
enum : int { HUD_ALIGN_LEFT = 1 };
enum : int { HUD_ALIGN_RIGHT = 2 };
enum : int { HUD_ALIGN_TOP = 1 };
enum : int { HUD_ALIGN_BOTTOM = 2 };

enum : int { HUD_PROJECTION_AUTO = 0 };
enum : int { HUD_PROJECTION_3D = 1 };
enum : int { HUD_PROJECTION_YSHEARING = 2 };

raw ACSUtils_Ints[55] = {
	240.0, // CursorY
	false, // R_TextColorIsString
	480.0, // CursorAreaHeight
	CR_UNTRANSLATED, // R_TextColor
	-1, // CachedPort
	0.0, // R_AppearTime
	HUD_STAYTIME_FOREVER, // R_StayTime
	1.0, // CursorSpeedY
	false, // CursorWrapX
	0.0, // R3D_CameraY
	false, // R_TextWordWrap
	0.0, // R3D_CameraPitch
	0.0, // R3D_2DOffsetX
	HUD_ALIGN_CENTER, // R_AlignX
	0, // R_RotatedX
	0.0, // R3D_Y
	320.0, // CursorPrevX
	HUD_PROJECTION_AUTO, // R3D_ProjectionMode
	0.0, // R_Y
	0.0, // R3D_CameraX
	0.0, // R3D_Z
	0.0, // R3D_2DOffsetY
	0, // R_RotatedZ
	640.0, // R_BaseWidth
	true, // R_ShowIn3DView
	1.0, // R_Alpha
	false, // R_CenterText
	HUDMSG_LAYER_OVERHUD, // R_Layer
	0.0, // R3D_CameraAngle
	0, // CursorMotionX
	1.0, // R_IScaleX
	1.0, // CursorSpeedX
	0.0, // R3D_X
	false, // R_LogMessage
	true, // R_ShowOnOverlayAutomap
	320.0, // CursorX
	0, // HudStateStackTop
	false, // R_ShowToEveryone
	0, // CursorMotionY
	HUD_BLENDSTYLE_NORMAL, // R_BlendStyle
	0.0, // R3D_CameraZ
	0.0, // R_X
	true, // R3D_AutoDistanceScale
	false, // CursorWrapY
	0, // R_RotatedY
	false, // R_ExcludeStatusBar
	480.0, // R_BaseHeight
	240.0, // CursorPrevY
	0.0, // R_DisappearTime
	HUD_ALIGN_CENTER, // R_AlignY
	true, // R_ShowOnFullAutomap
	1.0, // R_IScaleY
	false, // R_Is3DPoint
	640.0, // CursorAreaWidth
	false, // R_TextTypeOn
};

str ACSUtils_Strings[1] = {
	"SMALLFONT", // R_TextFont
};

private enum : int { ACSUTILS_ERROR_PROGRAM = 0 };
private enum : int { ACSUTILS_ERROR_MAPPING = 1 };
private enum : int { ACSUTILS_ERROR_LIMIT = 2 };

function void ACSUtils_ProgramError(str message)
{
	ACSUtils_ErrorHandler(ACSUTILS_ERROR_PROGRAM, message);
}

function void ACSUtils_LimitError(str message)
{
	ACSUtils_ErrorHandler(ACSUTILS_ERROR_LIMIT, message);
}

function void ACSUtils_ErrorHandler(int type, str message)
{
	str text = "";
	if (IsServer() != IsClient())
	{
		if (IsServer())
			text = "[\cgserverside\c-] ";
		else
			text = "[\cdclientside\c-] ";
	}
	
	text = StrParam(s:text, d:Timer(), s:" ACSUtils error: ", s:message);
	if (!IsClient())
		Log(s:text);

	if (GetCVar("acsutils_noerrors"))
		return;

	printbold(s:text);
}
enum : int { INT_MAX = 0x7fffffff };
enum : int { INT_MIN = 0x80000000 };
enum : fixed { FIXED_MAX = (fixed)(0x7fffffff) };
enum : fixed { FIXED_MIN = (fixed)(0x80000000) };
enum : int { USHORT_MAX = 65535 };
enum : int { SHORT_MAX = 32767 };
enum : int { SHORT_MIN = -32768 };
enum : int { UBYTE_MAX = 255 };
enum : int { SBYTE_MAX = 127 };
enum : int { SBYTE_MIN = -128 };

enum : fixed { PI = 3.1415926535897932384626433832795 };
enum : fixed { TAU = 6.2831853071795864769252867665590 };
enum : fixed { SQRT_2 = 1.41421356237 };
enum : fixed { MATH_E = 2.7182818284590452353602874713526624977572470937 };
enum : fixed { LOG2_E = 1.44269504089 };
enum : fixed { LOG2_10 = 3.32192809489 };

// Generic functions.

function raw min(raw a, raw b)
{
	if (a < b)
		return a;
	return b;
}

function raw max(raw a, raw b)
{
	if (a > b)
		return a;
	return b;
}

function int clamp(raw x, raw a, raw b)
{
	if (x > b)
		return b;
	if (x < a)
		return a;
	return x;
}	

function int sgn(raw x)
{
	if (x > 0)
		return 1;
	if (x < 0)
		return -1;
	return 0;
}

function int abs(raw x)
{
	if (x > 0)
		return x;
	return -x;
}

// From commonFuncs.h by Ijon Tichy.
function raw middle(raw x, raw y, raw z)
{
    if ((x < z) && (y < z)) { return max(x, y); }
    return max(min(x, y), z);
}

function int cmp(raw a, raw b)
{
	if (a > b)
		return 1;
	if (a < b)
		return -1;
	return 0;
}

function raw mod(raw a, raw b)
{
	if (a < 0)
	{
		int rem = a % b;
		if (rem != 0)
			return b + (a % b);
		return 0;
	}
	
	return a % b;
}

function raw cond(bool x, raw whentrue, raw whenfalse)
{
	if (x)
		return whentrue;
	return whenfalse;
}

function raw condTrue(raw x, raw whentrue)
{
	if (x)
		return whentrue;
	return x;
}

function raw condFalse(raw x, raw whenfalse)
{
	if (x)
		return x;
	return whenfalse;
}

// Rounding.

function fixed fract(fixed x)
{
	return x - trunc(x);
}

function fixed trunc(fixed x)
{
	if (x > 0.0)
		return floor(x);
	return ceil(x);
}

/* ZDOOM DEFINES ITS OWN VERSIONS OF floor, ceil AND round THAT SILENTLY RETURN 0 IN ZANDRONUM, PLEASE REMOVE THESE FUNCTIONS FROM FROM zspecial.acs OR RENAME THE ACSUTILS OR ZDOOM FUNCTIONS TO SOMETHING ELSE. */ function fixed floor(fixed x)
{
	return (fixed)((int)(x) & 0xffff0000);
}

/* ZDOOM DEFINES ITS OWN VERSIONS OF floor, ceil AND round THAT SILENTLY RETURN 0 IN ZANDRONUM, PLEASE REMOVE THESE FUNCTIONS FROM FROM zspecial.acs OR RENAME THE ACSUTILS OR ZDOOM FUNCTIONS TO SOMETHING ELSE. */function fixed ceil(fixed x)
{
	return (fixed)(((int)(x) - 1) & 0xffff0000) + 1.0;
}

/* ZDOOM DEFINES ITS OWN VERSIONS OF floor, ceil AND round THAT SILENTLY RETURN 0 IN ZANDRONUM, PLEASE REMOVE THESE FUNCTIONS FROM FROM zspecial.acs OR RENAME THE ACSUTILS OR ZDOOM FUNCTIONS TO SOMETHING ELSE. */ function fixed round(fixed x)
{
	return (fixed)((int)(x + 0.5) & 0xffff0000);
}

function int itrunc(fixed x)
{
	if (x > 0.0)
		return ifloor(x);
	return iceil(x);
}

function int ifloor(fixed x)
{
	return (int)(x)>>16;
}

function int iceil(fixed x)
{
	return ((int)(x) - 1 >> 16) + 1;
}

function int iround(fixed x)
{
	return (int)(x + 0.5) >> 16;
}


// Numerical algorithms.

function fixed AngleDiff(fixed a, fixed b)
{
	a = mod(a, 1.0);
	b = mod(b, 1.0);
	fixed diff = b - a;

	if (diff > 0.5)
		return diff - 1.0;
	else if (diff < -0.5)
		return diff + 1.0;
	return diff;
}


function int ipow(int x, int y)
{
    int n = 1;
    while (y-- > 0)
		n *= x;
    return n;
}

function fixed fpow(fixed x_, fixed y_)
{
	raw x = x_;
	raw y = y_;
	raw n = 1.0;
	if (y > 0)
	{
		while (y-- > 0)
			n = FixedMul(n, x);
		return n;
	}
	
	while (y++ < 0)
		n = FixedDiv(n, x);
	return n;
}

function fixed lerp(fixed a, fixed b, fixed alpha)
{
	return FixedMul(a, 1.0 - alpha) + FixedMul(b, alpha);
}

// From commonFuncs.h by Ijon Tichy.
function raw gcf(raw a, raw b)
{
    int c;
    while (1)
    {
        if (b == 0) { return a; }
        c = a % b;
        a = b;
        b = c;
    }
    
    return -1;
}

// By TechnoDoomed1
// fixed IntDiv(int a, int b)
function fixed IntDiv (int a_, int b_) {
    raw a = a_;
	raw b = b_;
	raw quotient = 0, current_fraction = 1.0;

    // Only works when the ratio is less than 32767 = 2^15 - 1.
    // Otherwise return 0.

    if ((abs(a) / abs(b)) > 32767) {
        return 0.0;
    }

    // Performs the same algorithm as hand division, but working with powers of 2 instead of 10.
    // This is done until we reach the maximum allowed precision, which is 1 (=2^-16 in fixed point).

    while (current_fraction > 1) {
        quotient += (a / b) * current_fraction;
        a = (a % b) * 2;
        current_fraction /= 2;
    }

    return (fixed)(quotient);
}

// raw, raw swap(raw a, raw b)
function void swap(raw a, raw b)
{
	r1 = b;
	r2 = a;
}

// Bit math.

function int getbit(int x, int n)
{
	return x & (1 << n);
}

function int clrbit(int p, int n)
{
	return p & ~(1 << n);
}

function int setbit(int p, int n)
{
	return p | ~(1 << n);
}

function int tglbit(int p, int n)
{
	return p ^ (1 << n);
}

function bool notflag(int flags, int flag)
{
	return !(flags & flag);
}

function bool randbool(void)
{
	return (bool)(Random(0, 1));
}

function int randint(void)
{
	return Random(INT_MIN, INT_MAX);
}

// From commonFuncs.h by Ijon Tichy.
function int randsign(void)
{
	return 2 * Random(0, 1) - 1;
}

function raw RandomPick2(raw v0, raw v1)
{
	if (Random(0, 1))
		return v0;
	return v1;
}

function raw RandomPick3(raw v0, raw v1, raw v2)
{
	int x = Random(0, 2);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	}

	return v2;
}

function raw RandomPick4(raw v0, raw v1, raw v2, raw v3)
{
	int x = Random(0, 3);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	}

	return v3;
}

function raw RandomPick5(raw v0, raw v1, raw v2, raw v3, raw v4)
{
	int x = Random(0, 4);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	}

	return v4;
}

function raw RandomPick6(raw v0, raw v1, raw v2, raw v3, raw v4, raw v5)
{
	int x = Random(0, 5);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	}

	return v5;
}

function raw RandomPick7(raw v0, raw v1, raw v2, raw v3, raw v4, raw v5, raw v6)
{
	int x = Random(0, 6);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	case 5: return v5;
	}

	return v6;
}

function raw RandomPick8(raw v0, raw v1, raw v2, raw v3, raw v4, raw v5, raw v6, raw v7)
{
	int x = Random(0, 7);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	case 5: return v5;
	case 6: return v6;
	}

	return v7;
}

function int npo2(int v)
{
	v--;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	v++;
	return v;
}

function int getNumDigits(int base, int number)
{
	int digits = 0;
	while (number)
	{
		digits++;
		number /= base;
	}
	return digits;
}

function int flag2index(int x)
{
	return getNumDigits(2, x) - 1;
}


// Logarithms.

// All logaritm functions written by TechnoDoomed1 unless stated otherwise

function fixed log2 (fixed x_) {
    raw x = x_;
	
	// We calculate the integral and decimal parts of the bit logarithm of x.
    raw integer_part = 0, decimal_part = 0;

    // The integral part is how many times we can divide by 2 until we reach a number in the range [1, 2).
    // If the number is on the range (0, 1) then we multiply by 2 until we reach a number in the range [1, 2).
    while (x < 1.0) {
        -- integer_part;
        x *= 2;
    }
    while (x >= 2.0) {
        ++ integer_part;
        x /= 2;
    }

    // Then, we square the number each time to get the next relevant byte, until we reach max precision allowed.
    // WHY? Because if 2^d = y, then (2^d)^2 = 2^(2d) = y^2, where d is the decimal part.
    //-----------------------------------------------------------------------------------------------------------------
    // Let's start with the fraction 1/2, and go downwards until we reach the max precision for a fixed-point number,
    // which is 1 (since it occupies the right side of the byte, it really represents 2^-16).

    raw current_fraction = 0.5;

    while (current_fraction > 1) {
        x = FixedMul(x, x);
        if (x >= 2.0) {
            decimal_part += current_fraction;
            x /= 2;
        }

        current_fraction /= 2;
    }

    // We can finally return the number as the integral part (shifted 16 bytes to the left, to be on the corresponding
    // integral part of the fixed-point number) plus the decimal part, which is the sum of all the fractions of 2 that
    // correspond to the solution of 2^d = y.

    return ((integer_part << 16) + decimal_part);
}

function fixed ilog2 (int x_) {
    raw x = x_;
	
	// We calculate the integral and decimal parts of the bit logarithm of x.
    raw integer_part = 0, decimal_part = 0;

    // The integral part is how many times we can divide by 2 until we reach a number lower than 2.
    // We lose precision by not keeping the fractional part until that part fits perfectly in a fixed number variable.
    while (x >= 32768) {
        ++ integer_part;
        x /= 2;
    }

    x <<= 16;

    while (x >= 2.0) {
        ++ integer_part;
        x /= 2;
    }

    // Then, we square the number each time to get the next relevant byte, until we reach max precision allowed.
    // WHY? Because if 2^d = y, then (2^d)^2 = 2^(2d) = y^2, where d is the decimal part.
    //-----------------------------------------------------------------------------------------------------------------
    // Let's start with the fraction 1/2, and go downwards until we reach the max precision for a fixed-point number,
    // which is 1 (since it occupies the right side of the byte, it really represents 2^-16).

    raw current_fraction = 0.5;

    while (current_fraction > 1) {
        x = FixedMul(x, x);
        if (x >= 2.0) {
            decimal_part += current_fraction;
            x /= 2;
        }

        current_fraction /= 2;
    }

    // We can finally return the number as the integral part (shifted 16 bytes to the left, to be on the corresponding
    // integral part of the fixed-point number) plus the decimal part, which is the sum of all the fractions of 2 that
    // correspond to the solution of 2^d = y.

    return ((integer_part << 16) + decimal_part);
}


function fixed ln (fixed x) {
    // This calculates the natural logarithm of a number using the property that:   ln(x) = log_2(x) / log_2(e)
    // This is done because calculating the log_2 of a number is far easier, specially with fixed-point arithmetics. 

    return FixedDiv(log2(x), LOG2_E);
}

// By Korshun.
function fixed iln (int x) {
	return FixedDiv(ilog2(x), LOG2_E);
}

// By Korshun.
function fixed log10 (fixed x) {
	return FixedDiv(log2(x), LOG2_10);
}

// By Korshun.
function fixed ilog10 (int x) {
	return FixedDiv(ilog2(x), LOG2_10);
}

function fixed logb (fixed x, fixed base) {
    // This calculates the logarithm in any base > 1.0, by using the property that:   log_b(x) = log_2(x) / log_2(b)
    // Otherwise, returns 0.

    if (base > 1.0)
        return FixedDiv(log2(x), log2(base));
   
    return 0.0;
}

// By Korshun.
function fixed ilogb (int x, fixed base) {
    // This calculates the logarithm in any base > 1.0, by using the property that:   log_b(x) = log_2(x) / log_2(b)
    // Otherwise, returns 0.

    if (base > 1.0)
        return FixedDiv(ilog2(x), log2(base));
   
    return 0.0;
}

// Trigonometry.

function fixed tan(fixed x)
{
	return FixedDiv(sin(x), cos(x));
}

function fixed cot(fixed x)
{
	return FixedDiv(cos(x), sin(x));
}

function fixed sec(fixed x)
{
	return FixedDiv(1.0, sin(x));
}

function fixed cosec(fixed x)
{
	return FixedDiv(1.0, cos(x));
}

function fixed atan(fixed x)
{
    return VectorAngle(1.0, x);
}

function fixed asin(fixed x)
{
	return atan(FixedDiv(x, FixedSqrt(1.0 - FixedMul(x, x))));
}

function fixed acos(fixed x)
{
	return (fixed)((int)(2) * (int)(atan(FixedSqrt(FixedDiv(1.0 - x, 1.0 + x)))));
}

function fixed acot(fixed x)
{
 	return 0.25 - atan(x);
}

function fixed asec(fixed x)
{
	return acos(FixedDiv(1.0, x));
}

function fixed acosec(fixed x)
{
	 return asin(FixedDiv(1.0, x));
}

// Vectors.

// fixed, fixed RotateVector(fixed x, fixed y, fixed angle);
function void RotateVector(fixed x, fixed y, fixed angle)
{
	// Rotate around Z axis.
	fixed s = sin(angle);
	fixed c = cos(angle);
	r1 = FixedMul(x, c) - FixedMul(y, s);
	r2 = FixedMul(x, s) + FixedMul(y, c);
}

// fixed, fixed RotateVectorCS(fixed x, fixed y, fixed c, fixed s);
function void RotateVectorCS(fixed x, fixed y, fixed c, fixed s)
{
	// Rotate around Z axis.
	r1 = FixedMul(x, c) - FixedMul(y, s);
	r2 = FixedMul(x, s) + FixedMul(y, c);
}

// fixed, fixed RotatePoint(fixed x, fixed y, fixed originX, fixed originY, fixed angle)
function void RotatePoint(fixed x, fixed y, fixed originX, fixed originY, fixed angle)
{
	x -= originX;
	y -= originY;
	RotateVector(x, y, angle);
	r1 += originX;
	r2 += originY;
}

// fixed, fixed VectorToAngles(fixed x, fixed y, fixed z)
function void VectorToAngles(fixed x, fixed y, fixed z)
{
	fixed xy = VectorLength(x, y);
		
	r1 = VectorAngle(x, y);
	r2 = VectorAngle(xy, z);
}

// fixed, fixed, fixed AnglesToVector(fixed angle, fixed pitch)
function void AnglesToVector(fixed angle, fixed pitch)
{
	fixed cos_pitch = cos(pitch);
	r1 = FixedMul(cos_pitch, cos(angle));
    r2 = FixedMul(cos_pitch, sin(angle));
    r3 = sin(pitch);
}

function fixed VectorLength3D(fixed x, fixed y, fixed z)
{
	 return VectorLength(VectorLength(x, y), z);
}

function fixed SqVectorLength(fixed x, fixed y)
{
	return FixedMul(x, x) + FixedMul(y, y);
}

function fixed SqVectorLength3D(fixed x, fixed y, fixed z)
{
	return FixedMul(x, x) + FixedMul(y, y) + FixedMul(z, z);
}

function fixed dot2(fixed x1, fixed y1, fixed x2, fixed y2)
{
	return FixedMul(x1, x2) + FixedMul(y1, y2);
}

function fixed dot3(fixed x1, fixed y1, fixed z1, fixed x2, fixed y2, fixed z2)
{
	return FixedMul(x1, x2) + FixedMul(y1, y2) + FixedMul(z1, z2);
}

function void normalize2d(fixed x, fixed y)
{
	fixed l = VectorLength(x, y);
	r1 = FixedDiv(x, l);
	r2 = FixedDiv(y, l);
}

function void normalize3d(fixed x, fixed y, fixed z)
{
	fixed l = VectorLength3D(x, y, z);
	r1 = FixedDiv(x, l);
	r2 = FixedDiv(y, l);
	r3 = FixedDiv(z, l);
}

enum : int { COLORCODE = 28 };

private enum : int { ACSUTILS_ISALNUM = 1<<0 };
private enum : int { ACSUTILS_ISALPHA = 1<<1 };
private enum : int { ACSUTILS_ISBLANK = 1<<2 };
private enum : int { ACSUTILS_ISCNTRL = 1<<3 };
private enum : int { ACSUTILS_ISDIGIT = 1<<4 };
private enum : int { ACSUTILS_ISGRAPH = 1<<5 };
private enum : int { ACSUTILS_ISLOWER = 1<<6 };
private enum : int { ACSUTILS_ISPRINT = 1<<7 };
private enum : int { ACSUTILS_ISPUNCT = 1<<8 };
private enum : int { ACSUTILS_ISSPACE = 1<<9 };
private enum : int { ACSUTILS_ISUPPER = 1<<10 };
private enum : int { ACSUTILS_ISXDIGIT = 1<<11 };


int ACSUtils_AsciiTypes[128] =
{
ACSUTILS_ISCNTRL, // NUL
ACSUTILS_ISCNTRL, // SOH
ACSUTILS_ISCNTRL, // STX
ACSUTILS_ISCNTRL, // ETX
ACSUTILS_ISCNTRL, // EOT
ACSUTILS_ISCNTRL, // ENQ
ACSUTILS_ISCNTRL, // ACK
ACSUTILS_ISCNTRL, // BEL
ACSUTILS_ISCNTRL, // BS
ACSUTILS_ISBLANK | ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // TAB
ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // LF
ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // VT
ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // FF
ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // CR
ACSUTILS_ISCNTRL, // SO
ACSUTILS_ISCNTRL, // SI
ACSUTILS_ISCNTRL, // DLE
ACSUTILS_ISCNTRL, // DC1
ACSUTILS_ISCNTRL, // DC2
ACSUTILS_ISCNTRL, // DC3
ACSUTILS_ISCNTRL, // DC4
ACSUTILS_ISCNTRL, // NAK
ACSUTILS_ISCNTRL, // SYN
ACSUTILS_ISCNTRL, // ETB
ACSUTILS_ISCNTRL, // CAN
ACSUTILS_ISCNTRL, // EM
ACSUTILS_ISCNTRL, // SUB
ACSUTILS_ISCNTRL, // ESC
ACSUTILS_ISCNTRL, // FS (COLORCODE)
ACSUTILS_ISCNTRL, // GS
ACSUTILS_ISCNTRL, // RS
ACSUTILS_ISCNTRL, // US
ACSUTILS_ISBLANK | ACSUTILS_ISPRINT | ACSUTILS_ISSPACE, // Space
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // !
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // "
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // #
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // $
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // %
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // &
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // '
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // (
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // )
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // *
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // +
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ,
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // -
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // .
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // /
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 0
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 1
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 2
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 3
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 4
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 5
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 6
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 7
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 8
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 9
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // :
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ;
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // <
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // =
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // >
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ?
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // @
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // A
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // B
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // C
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // D
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // E
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // F
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // G
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // H
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // I
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // J
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // K
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // L
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // M
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // N
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // O
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // P
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // Q
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // R
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // S
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // T
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // U
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // V
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // W
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // X
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // Y
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // Z
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // [
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // \
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ]
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ^
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // _
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // `
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // a
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // b
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // c
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // d
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // e
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // f
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // g
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // h
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // i
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // j
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // k
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // l
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // m
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // n
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // o
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // p
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // q
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // r
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // s
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // t
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // u
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // v
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // w
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // x
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // y
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // z
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // {
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // |
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // }
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ~
ACSUTILS_ISCNTRL, // DEL
};

function bool isalnum(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISALNUM);
}

function bool isalpha(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISALPHA);
}

function bool isblank(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISBLANK);
}

function bool iscntrl(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISCNTRL);
}

function bool isdigit(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISDIGIT);
}

function bool isgraph(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISGRAPH);
}

function bool islower(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISLOWER);
}

function bool isprint(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISPRINT);
}

function bool ispunct(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISPUNCT);
}

function bool isspace(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISSPACE);
}

function bool isupper(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISUPPER);
}

function bool isxdigit(int c)
{
	return (bool)(ACSUtils_AsciiTypes[c] & ACSUTILS_ISXDIGIT);
}

function bool isascii(int c)
{
	return c >= 0 && c < 128;
}

function int toupper(int c)
{
	if (islower(c))
		return c - 32;
	return c;
}

function int tolower(int c)
{
	if (isupper(c))
		return c + 32;
	return c;
}


// String versions
function bool StrIsAlNum(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isalnum(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsAlpha(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isalpha(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsBlank(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isblank(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsCntrl(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!iscntrl(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsDigit(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isdigit(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsGraph(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isgraph(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsLower(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!islower(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsPrint(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isprint(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsSpace(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isspace(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsUpper(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isupper(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsXDigit(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isxdigit(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsAscii(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
	{
		int char = GetChar(s, i);
		if (char < 0 || char > 127)
			return false;
	}
	return true;
}

// Case conversion.

function str StrToLower(str s)
{
	str result = "";
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		result = StrParam(s:result, c:tolower(GetChar(s, i)));
		
	return result;
}

function str StrToUpper(str s)
{
	str result = "";
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		result = StrParam(s:result, c:toupper(GetChar(s, i)));
		
	return result;
}

// Basic
function bool StrIsEmpty(str s)
{
	if (!GetChar(s, 0))
		return true;
	return false;
}


// StrAdd
function str StrAdd(str a, str b)
{
	return StrParam(s:a, s:b);
}

function str StrAddInt(str a, int b)
{
	return StrParam(s:a, d:b);
}

function str StrAddChar(str a, int b)
{
	return StrParam(s:a, c:b);
}

function str StrAddFixed(str a, fixed b)
{
	return StrParam(s:a, f:b);
}

// StrEquals
function bool StrEquals(str a, str b)
{
    return StrCmp(a, b) == 0;
}	

function bool StrIEquals(str a, str b)
{
	return StrICmp(a, b) == 0;
}

function bool StrEqualsAt(str s, int where, str what)
{
	int len = StrLen(what);
	if (where + len > StrLen(s))
		return false;
	
	return StrEquals(StrMid(s, where, len), what);
}

function bool StrIEqualsAt(str s, int where, str what)
{
	int len = StrLen(what);
	if (where + len > StrLen(s))
		return false;
	
	return StrIEquals(StrMid(s, where, len), what);
}

function bool StrStartsWith(str s, str sub)
{
	return StrEqualsAt(s, 0, sub);
}

function bool StrStartsWithI(str s, str sub)
{
	return StrIEqualsAt(s, 0, sub);
}

function bool StrEndsWith(str s, str what)
{
	int len1 = StrLen(s);
	int len2 = StrLen(what);

	if (len1 < len2)
		return false;
	return StrEqualsAt(s, len1 - len2, what);
}

function bool StrEndsWithI(str s, str what)
{
	int len1 = StrLen(s);
	int len2 = StrLen(what);

	if (len1 < len2)
		return false;
	return StrIEqualsAt(s, len1 - len2, what);
}

// StrFind
function int StrFind(str s, str what)
{
	return StrFindFrom(s, what, 0);
}

function int StrFindI(str s, str what)
{
	return StrFindFromI(s, what, 0);
}

function int StrRFind(str s, str what)
{
	return StrRFindFrom(s, what, StrLen(s) - 1);
}

function int StrRFindI(str s, str what)
{
	return StrRFindFromI(s, what, StrLen(s) - 1);
}

function int StrFindFrom(str s, str what, int start)
{
	int len = StrLen(s) - StrLen(what);
	for (int i = start; i <= len; i++)
	{
		if (StrEqualsAt(s, i, what))
			return i;
	}
	
	return -1;
}

function int StrFindFromI(str s, str what, int start)
{
	int len = StrLen(s) - StrLen(what);
	for (int i = start; i <= len; i++)
	{
		if (StrIEqualsAt(s, i, what))
			return i;
	}
	
	return -1;
}

function int StrRFindFrom(str s, str what, int start)
{
	int len = StrLen(s) - StrLen(what);
	for (int i = start; i >= 0; i--)
	{
		if (StrEqualsAt(s, i, what))
			return i;
	}
	
	return -1;
}

function int StrRFindFromI(str s, str what, int start)
{
	int len = StrLen(s) - StrLen(what);
	for (int i = start; i >= 0; i--)
	{
		if (StrIEqualsAt(s, i, what))
			return i;
	}
	
	return -1;
}

// StrRemove
function str StrRemove(str s, str what)
{
	return StrReplace(s, what, "");
}

function str StrRemoveI(str s, str what)
{
	return StrReplaceI(s, what, "");
}

function str StrRemoveFirst(str s, str what)
{
	return StrRemoveFirstFrom(s, what, 0);
}

function str StrRemoveFirstI(str s, str what)
{
	return StrRemoveFirstFromI(s, what, 0);
}

function str StrRemoveLast(str s, str what)
{
	return StrRemoveLastFrom(s, what, StrLen(s) - 1);
}

function str StrRemoveLastI(str s, str what)
{
	return StrRemoveLastFromI(s, what, StrLen(s) - 1);
}

function str StrRemoveFirstFrom(str s, str what, int start)
{
	int pos = StrFindFrom(s, what, start);
	if (pos != -1)
		return StrCut(s, pos, StrLen(what));
	return s;
}

function str StrRemoveFirstFromI(str s, str what, int start)
{
	int pos = StrFindFromI(s, what, start);
	if (pos != -1)
		return StrCut(s, pos, StrLen(what));
	return s;
}

function str StrRemoveLastFrom(str s, str what, int start)
{
	int pos = StrRFindFrom(s, what, start);
	if (pos != -1)
		return StrCut(s, pos, StrLen(what));
	return s;
}

function str StrRemoveLastFromI(str s, str what, int start)
{
	int pos = StrRFindFromI(s, what, start);
	if (pos != -1)
		return StrCut(s, pos, StrLen(what));
	return s;
}

// StrReplace
function str StrReplace(str s, str what, str with)
{
	int len1 = StrLen(s);
	int len2 = StrLen(what);
	int start = 0;
	int end = 0;
	str result = "";

	while (true)
	{
		end = StrFindFrom(s, what, start);
		if (end == -1)
		{
			result = StrParam(s:result, s:StrSlice(s, start, end));
			break;
		}

		result = StrParam(s:result, s:StrSlice(s, start, end), s:with);
		start = end + len2;
	}
	
	return result;
}

function str StrReplaceI(str s, str what, str with)
{
	int len1 = StrLen(s);
	int len2 = StrLen(what);
	int start = 0;
	int end = 0;
	str result = "";

	while (true)
	{
		end = StrFindFromI(s, what, start);
		if (end == -1)
		{
			result = StrParam(s:result, s:StrSlice(s, start, end));
			break;
		}

		result = StrParam(s:result, s:StrSlice(s, start, end), s:with);
		start = end + len2;
	}
	
	return result;
}

function str StrReplaceFirst(str s, str what, str with)
{
	return StrReplaceFirstFrom(s, what, with, 0);
}

function str StrReplaceFirstI(str s, str what, str with)
{
	return StrReplaceFirstFromI(s, what, with, 0);
}

function str StrReplaceLast(str s, str what, str with)
{
	return StrReplaceLastFrom(s, what, with, StrLen(s) - 1);
}

function str StrReplaceLastI(str s, str what, str with)
{
	return StrReplaceLastFromI(s, what, with, StrLen(s) - 1);
}

function str StrReplaceFirstFrom(str s, str what, str with, int start)
{
	int pos = StrFind(s, what);
	if (pos != -1)
		return StrInsert(StrCut(s, pos, StrLen(what)), pos, with);
	return s;
}

function str StrReplaceFirstFromI(str s, str what, str with, int start)
{
	int pos = StrFindI(s, what);
	if (pos != -1)
		return StrInsert(StrCut(s, pos, StrLen(what)), pos, with);
	return s;
}

function str StrReplaceLastFrom(str s, str what, str with, int start)
{
	int pos = StrRFind(s, what);
	if (pos != -1)
		return StrInsert(StrCut(s, pos, StrLen(what)), pos, with);
	return s;
}

function str StrReplaceLastFromI(str s, str what, str with, int start)
{
	int pos = StrRFindI(s, what);
	if (pos != -1)
		return StrInsert(StrCut(s, pos, StrLen(what)), pos, with);
	return s;
}

// Misc
function str LeftPad(str s, int c, int size)
{
	int len = StrLen(s);
	if (len >= size)
		return s;
		
	int diff = size - len;
	str pad = "";
	for (int i = 0; i < diff; i++)
		pad = StrParam(s:pad, c:c);
		
	return StrParam(s:pad, s:s);
}

function str RightPad(str s, int c, int size)
{
	int len = StrLen(s);
	if (len >= size)
		return s;
		
	int diff = size - len;
	str pad = "";
	for (int i = 0; i < diff; i++)
		pad = StrParam(s:pad, c:c);
		
	return StrParam(s:s, s:pad);
}

function str StrCapitalize(str s)
{
	if (StrLen(s) == 0)
		return "";

	str result = StrParam(c:toupper(GetChar(s, 0)));
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		result = StrParam(s:result, c:tolower(GetChar(s, i)));

	return result;
}

function bool StrContains(str s, str what)
{
	return StrFind(s, what) >= 0;
}

function bool StrContainsI(str s, str what)
{
	return StrFindI(s, what) >= 0;
}

function str StrCut(str s, int start, int length)
{
	return StrParam(s:StrLeft(s, start), s:StrRightFrom(s, start + length));
}

function str StrCutRange(str s, int start, int end)
{
	return StrParam(s:StrLeft(s, start), s:StrRightFrom(s, end));
}

function str StrInsert(str s, int where, str what)
{
	return StrParam(s:StrLeft(s, where), s:what, s:StrRightFrom(s, where));
}

function str StrSlice(str s, int start, int end)
{
	return StrMid(s, start, end - start);
}

function void StrSplit(str s, str separator)
{
	int pos = StrFind(s, separator);
	if (pos != -1)
	{
		r1 = StrLeft(s, pos);
		r2 = StrRightFrom(s, pos + StrLen(separator));
	}
	else
	{
		r1 = s;
		r2 = "";
	}
}

function void StrSplitI(str s, str separator)
{
	int pos = StrFindI(s, separator);
	if (pos != -1)
	{
		r1 = StrLeft(s, pos);
		r2 = StrRightFrom(s, pos + StrLen(separator));
	}
	else
	{
		r1 = s;
		r2 = "";
	}
}

function str StrRightFrom(str s, int from)
{
	return StrRight(s, StrLen(s) - from);
}

function str StrRepeat(str s, int n)
{
	str result = "";
	for (int i = 0; i < n; i++)
		result = StrAdd(result, s);
	return result;
}

function str StrReverse(str s)
{
	str tempstr = "";
	for(int i = StrLen(s)-1; i >= 0; i--)
		tempstr = StrParam(s:tempstr, c:GetChar(s, i));
	return tempstr;
}

// Color codes.
function bool IsColorCodeChar(int c)
{
	return (c >= 'a' && c <= 'v')
		|| c == '-'
		|| c == '+'
		|| c == '*'
		|| c == '!';
}

function int SkipColorCodeAt(str s, int i)
{
	if (GetChar(s, i) == COLORCODE)
	{
		i++;
	}
	else
	{
		return i;
	}
	
	if (GetChar(s, i) == '[')
	{
		int len = StrLen(s);
		for (; i < len; i++)
		{
			if (GetChar(s, i) == ']')
			{
				i++;
				break;
			}
		}
	}
	else if (IsColorCodeChar(GetChar(s, i)))
	{
		return i + 1;
	}
	
	return i;
}
	
function str GetColorCodeAt(str s, int i)
{
	return StrSlice(s, i, SkipColorCodeAt(s, i));
}
	
function bool HasColorCodes(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
	{
		if (GetChar(s, i) == COLORCODE)
			i += 1;
		else
			continue;
			
		int c = GetChar(s, i);
		if (c == '[' || IsColorCodeChar(c))
			return true;
	}
	return false;
}

function str StripColorCodes(str s)
{
	str result = "";
	for (int i = 0; i < StrLen(s); i++)
	{
		i = SkipColorCodeAt(s, i);
		result = StrParam(s:result, c:GetChar(s, i));
	}

	return result;
}

enum : int { MAX_PLAYERS = 64 };
enum : int { MAX_PLAYERS_ZDOOM = 8 };
enum : int { TEAM_NONE = 255 };

// Inventory functions.

function void GiveMaxInventory(str item)
{
	GiveInventory(item, INT_MAX);
}

function void GiveMaxActorInventory(int tid, str item)
{
	GiveActorInventory(tid, item, INT_MAX);
}

function void TakeMaxInventory(str item)
{
	TakeInventory(item, INT_MAX);
}

function void TakeMaxActorInventory(int tid, str item)
{
	TakeActorInventory(tid, item, INT_MAX);
}

function void SetInventory(str item, int amount)
{
	int diff = amount - CheckInventory(item);
	if (diff > 0)
		GiveInventory(item, diff);
	else if (diff < 0)
		TakeInventory(item, -diff);
}

function void SetActorInventory(int tid, str item, int amount)
{
	int diff = amount - CheckActorInventory(tid, item);
	if (diff > 0)
		GiveActorInventory(tid, item, diff);
	else if (diff < 0)
		TakeActorInventory(tid, item, -diff);
}

function void ToggleInventory(str item)
{
	if (CheckInventory(item) > 0)
		SetInventory(item, 0);
	else
		SetInventory(item, 1);
}

function void ToggleActorInventory(int tid, str item)
{
	if (CheckActorInventory(tid, item) > 0)
		SetActorInventory(tid, item, 0);
	else
		SetActorInventory(tid, item, 1);
}


// CVar functions.

function fixed a_GetCVarFixed(str name)
{
	str value = GetCVarString(name);
	if ((int)(value) != 0)
		return atof(GetCVarString(name));
	return 0.0;
}

function fixed a_GetUserCVarFixed(int player, str name)
{
	str value = GetUserCVarString(player, name);
	if ((int)(value) != 0)
		return atof(GetUserCVarString(player, name));
	return 0.0;
}


// Screen info functions.

function bool StatusBarVisible(void)
{
	return GetCVar("screenblocks") <= 10;
}


// HudMessage functions

function void ClearHudMessage(int id)
{
	HudMessage(s:""; HUDMSG_PLAIN, id, 0, 0.0, 0.0, 0.0, 0.0);
}

function void ClearHudMessageBold(int id)
{
	HudMessageBold(s:""; HUDMSG_PLAIN, id, 0, 0.0, 0.0, 0.0, 0.0);
}


// Actor information functions

function str ActivatorName(void)
{
	return StrParam(n:0);
}

script "ACSUtils_GetActorName" (int tid)
{
	SetActivator(tid);
	SetResultValue((int)(StrParam(n:0)));
}

function str GetActorName(int tid)
{
	return (raw)ACS_NamedExecuteWithResult("ACSUtils_GetActorName", tid);
}

function bool IsAlive(void)
{
	if (IsPlayer())
		if (!PlayerInGame(PlayerNumber()))
			return false;
	return GetActorProperty(0, APROP_HEALTH) > 0;
}

function bool ActorIsAlive(int tid)
{
	if (tid == 0 && IsPlayer())
		if (!PlayerInGame(PlayerNumber()))
			return false;
	return GetActorProperty(tid, APROP_HEALTH) > 0;
}

function bool ActorExists(int tid)
{
	if (tid != 0)
		return ClassifyActor(tid) != ACTOR_NONE;
	return notflag(ClassifyActor(tid), ACTOR_WORLD);
}

// Actor math functions.

function fixed ActorDistance(int tid1, int tid2)
{
	return VectorLength3D(GetActorX(tid2) - GetActorX(tid1),
	                      GetActorY(tid2) - GetActorY(tid1),
	                      GetActorZ(tid2) - GetActorZ(tid1));
}

function fixed ActorDistance2D(int tid1, int tid2)
{
	return VectorLength(GetActorX(tid2) - GetActorX(tid1),
	                    GetActorY(tid2) - GetActorY(tid1));
}

function fixed GetActorVelocity(int tid)
{
	return VectorLength3D(GetActorVelX(tid), GetActorVelY(tid), GetActorVelZ(tid));
}

function fixed GetActorXYVelocity(int tid)
{
	return VectorLength(GetActorVelX(tid), GetActorVelY(tid));
}

function fixed GetActorVelocityXY(int tid)
{
	return VectorLength(GetActorVelX(tid), GetActorVelY(tid));
}

// Actor utility functions.

function bool HasRoomFor(str classname, fixed x, fixed y, fixed z)
{
	int tid = UniqueTid();
	if (!Spawn(classname, x, y, z, tid))
		return false;
	Thing_Remove(tid);
	return true;
}

function void LookAtPoint(int tid, fixed x, fixed y, fixed z)
{ 	
	x -= GetActorX(tid);
	y -= GetActorY(tid);
	z -= GetActorZ(tid) + GetActorViewHeight(tid);

	VectorToAngles(x, y, z);
	fixed angle = r1;
	fixed pitch = r2;

	SetActorAngle(tid, angle);
	SetActorPitch(tid, -pitch);
}

function void LookAt(int tid, int target)
{
	fixed x = GetActorX(target);
	fixed y = GetActorY(target);
	fixed z = GetActorZ(target) + GetActorViewHeight(target);
	LookAtPoint(tid, x, y, z);
}


// ChangeFlag

// Implementation from ACS-X.

function str ACSUtils_ChangeFlagName(str flag, bool value)
{
	return StrParam(s:"ACSUtils_CF_", s:flag, s:"_", d:(int)(!!value));
}

function void ChangeFlag(str flag, bool value)
{
	GiveInventory(ACSUtils_ChangeFlagName(flag, value), 1);
}

function void ChangeActorFlag(int tid, str flag, bool value)
{
	GiveActorInventory(tid, ACSUtils_ChangeFlagName(flag, value), 1);
}


// Mapping functions.

// From ZDoom wiki.
function int SyncSpeed(int newdistance, int syncdistance, int syncspd)
{
	fixed t = fixeddiv((fixed)(syncdistance<<16), (fixed)(syncspd<<16));
	fixed r = fixeddiv((fixed)(newdistance<<16), t);
	return (int)(r)>>16;
}
//===========================
// INTEGER PACKING
//===========================

// Pack unsigned 8-bit values. ========================================
function int PackBytes(int a, int b, int c, int d)
{
	return (a<<24) | (b<<16) | (c<<8) | d;
}
function int UnpackByte1(int x) { return (x>>24) & 0x000000FF; }
function int UnpackByte2(int x) { return (x>>16) & 0x000000FF; }
function int UnpackByte3(int x) { return (x>>8)  & 0x000000FF; }
function int UnpackByte4(int x) { return (x>>0)  & 0x000000FF; }


// Pack signed 16-bit values. =========================================
function int PackShorts(int a, int b)
{
	return ((a + 0x8000)<<16) | ((b + 0x8000) & 0x0000FFFF);
}
function int UnpackShort1(int x) { return ((x>>16) & 0x0000FFFF) - 0x8000; }
function int UnpackShort2(int x) { return ((x    ) & 0x0000FFFF) - 0x8000; }
// By FusedQyou
function bool KeyBound (str key)
{
	if (!IsClient())
	{
		ACSUtils_ProgramError(StrParam(s:"KeyBound called serverside with key = \"", s:key, s:"\", returning false"));
		return false;
	}
	return !StrEquals(StrParam(k:key), StrParam(s:"??? (", s:key, s:")"));
}

// By Monsterovich.

function bool KeyUp(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if ((~buttons & key) == key) { return true; }
		return false;
}

function bool KeyUpAny(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if (~buttons & key) { return true; }
		return false;
}

function bool PlayerKeyUp(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if ((~buttons & key) == key) { return true; }
		return false;
}

function bool PlayerKeyUpAny(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if (~buttons & key) { return true; }
		return false;
}


function bool KeyDown(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if ((buttons & key) == key) { return true; }
		return false;
}

function bool KeyDownAny(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if (buttons & key) { return true; }
		return false;
}

function bool PlayerKeyDown(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if ((buttons & key) == key) { return true; }
		return false;
}

function bool PlayerKeyDownAny(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if (buttons & key) { return true; }
		return false;
}


function bool KeyPressed(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

function bool KeyPressedAny(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if (newbuttons & key) { return true; }
		return false;
}

function bool PlayerKeyPressed(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

function bool PlayerKeyPressedAny(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if (newbuttons & key) { return true; }
		return false;
}


function bool KeyReleased(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

function bool KeyReleasedAny(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

	if (newbuttons & key) { return true; }
		return false;
}

function bool PlayerKeyReleased(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

function bool PlayerKeyReleasedAny(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

	if (newbuttons & key) { return true; }
		return false;
}


function bool KeyToggled(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons);

	if ((newbuttons & key) == key) { return true; }
		return false;
}

function bool KeyToggledAny(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons);

	if (newbuttons & key) { return true; }
		return false;
}

function bool PlayerKeyToggled(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons);

	if ((newbuttons & key) == key) { return true; }
		return false;
}

function bool PlayerKeyToggledAny(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons);

	if (newbuttons & key) { return true; }
		return false;
}
// Angles

function fixed deg2ang(fixed degrees)
{
	return FixedDiv(degrees, 360.0);
}

function fixed rad2ang(fixed radians)
{
	return FixedDiv(radians, TAU);
}

function fixed ang2deg(fixed angle)
{
	return FixedMul(angle, 360.0);
}

function fixed ang2rad(fixed angle)
{
	return FixedMul(angle, TAU);
}

function fixed deg2rad(fixed degrees)
{
	return FixedDiv(degrees, 57.29577951308232);
}

function fixed rad2deg(fixed radians)
{
	return FixedMul(radians, 57.29577951308232);
}

function int ang2byte(fixed angle)
{
    return (int)(angle)>>8;
}

function fixed byte2ang(int angle)
{
    return (fixed)(angle<<8);
}

// Gravity

function fixed GetGravityG(void)
{
	int sv_gravity = GetCVar("sv_gravity");
	if (sv_gravity > SHORT_MAX || sv_gravity < SHORT_MIN)
		return IntDiv(sv_gravity, 800);
	return FixedDiv(a_GetCVarFixed("sv_gravity"), 800.0);
}

function void SetGravityG(fixed gravity)
{
	SetGravity(FixedMul(gravity, 800.0));
}

function fixed grav2accel(fixed grav)
{
	return FixedDiv(grav, 800.0);
}

function fixed accel2grav(fixed accel)
{
	return FixedMul(accel, 800.0);
}

function fixed height2jumpz(fixed height, fixed gravity)
{
	return FixedSqrt((fixed)(2 * (int)(FixedMul(height, gravity))));
}

function fixed jumpz2height(fixed jumpz, fixed gravity)
{
	return (fixed)((int)(FixedDiv(FixedMul(jumpz, jumpz), gravity)) / 2);
}

enum : int { PARSENUMBER_SUCCESS = 0 };
enum : int { PARSENUMBER_OVERFLOW = 1 };
enum : int { PARSENUMBER_BADFORMAT = 2 };

function int ACSUtils_CheckRadix(int radix, str functionName)
{
	if (radix <= 0)
	{
		ACSUtils_ProgramError(StrParam(s:functionName, s:": invalid radix ", d:radix, s:". Assuming base 10."));
		return 10;
	}
	else if (radix > 36)
	{
		ACSUtils_ProgramError(StrParam(s:functionName, s:" only supports bases up to 36 (10 digits + 26 letters), but was requested to parse base ", d:radix, s:". Assuming base 10."));
		return 10;
	}
	return radix;
}

function void ACSUtils_ParseSign(str s, int i)
{
	if (GetChar(s, i) == '+')
	{
		r1 = 1;
		r2 = i + 1;
		return;
	}
	else if (GetChar(s, i) == '-')
	{
		r1 = -1;
		r2 = i + 1;
		return;
	}
	
	r1 = 1;
	r2 = i;
	return;
}
	
function void ACSUtils_ParseBasePrefix(str s, int i)
{
	if (StrIEqualsAt(s, i, "0x"))
	{
		r1 = 16;
		r2 = i + 2;
		return;
	}
	else if (StrIEqualsAt(s, i, "0o"))
	{
		r1 = 8;
		r2 = i + 2;
		return;
	}
	else if (StrIEqualsAt(s, i, "0b"))
	{
		r1 = 2;
		r2 = i + 2;
		return;
	}
	
	r1 = 0;
	r2 = i;
	return;
}

function int ACSUtils_ParseDigit(int c, int radix)
{
	int digit;
	if (c >= '0' && c <= '9')
		digit = c - '0';
	else if (c >= 'a' && c <= 'z')
		digit = c - 'a' + 10;
	else if (c >= 'A' && c <= 'Z')
		digit = c - 'A' + 10;
	else
		return -1;
		
	if (digit < radix)
		return digit;
	return -1;
}

function void ParseInt(str s, int radix)
{
	int i = 0;
	int sign = 1;
	radix = ACSUtils_CheckRadix(radix, "ParseInt");
	
	ACSUtils_ParseSign(s, i);
	sign = r1;
	i = r2;

	ACSUtils_ParseBasePrefix(s, i);
	radix = condFalse(r1, radix);
	i = r2;
	
	int len = StrLen(s);
	if (i == len)
	{
		r1 = PARSENUMBER_BADFORMAT;
		r2 = 0;
	}	
	
	int maxresult = cond(sign > 0, INT_MAX, INT_MIN);
	int limit = abs(maxresult / radix);
	int result = 0;
	bool overflowed = false;
	for (; i < len; i++)
	{
		int c = GetChar(s, i);
		int digit = ACSUtils_ParseDigit(c, radix);
		if (digit < 0)
		{
			r1 = PARSENUMBER_BADFORMAT;
			r2 = 0;
			return;
		}
		
		if (limit >= abs(result) && result != INT_MIN)
			result = result * radix + sign * digit;
		else
			overflowed = true;			
	}
	
	if (overflowed)
	{
		r1 = PARSENUMBER_OVERFLOW;
		r2 = maxresult;
		return;
	}
	else
	{
		r1 = PARSENUMBER_SUCCESS;
		r2 = result;
		return;
	}
}
	
function void ParseFixed(str s, int radix)
{
	int i = 0;
	int sign = 1;
	radix = ACSUtils_CheckRadix(radix, "ParseFixed");
	
	ACSUtils_ParseSign(s, i);
	sign = r1;
	i = r2;

	ACSUtils_ParseBasePrefix(s, i);
	radix = condFalse(r1, radix);
	i = r2;
	
	int len = StrLen(s);
	if (i == len)
	{
		r1 = PARSENUMBER_BADFORMAT;
		r2 = 0;
	}
	
	int maxresult = cond(sign > 0, INT_MAX, INT_MIN);
	int limit = abs(maxresult / radix);
	int result = 0;
	bool overflowed = false;
	bool hasfraction = false;
	int digit;
	for (; i < len; i++)
	{
		int c = GetChar(s, i);
		if (c == '.')
		{
			hasfraction = true;
			break;
		}
		
		digit = ACSUtils_ParseDigit(c, radix);
		if (digit < 0)
		{
			r1 = PARSENUMBER_BADFORMAT;
			r2 = 0;
			return;
		}
		
		if (limit >= abs(result) && result != INT_MIN)
			result = result * radix + sign * (digit<<16);
		else
			overflowed = true;			
	}
	
	if (hasfraction)
	{
		i++;
		
		int divisor = radix;
		for (; i < len; i++)
		{
			digit = ACSUtils_ParseDigit(GetChar(s, i), radix);
			if (digit < 0)
			{
				r1 = PARSENUMBER_BADFORMAT;
				r2 = 0;
				return;
			}
			
			if (divisor <= (radix<<16))
			{
				result = result + sign * (digit<<16) / divisor;
				if (sign < 0 && result > 0)
				{
					overflowed = true;
					break;
				}
				divisor *= radix;
			}
		}
	}			
	
	if (overflowed)
	{
		r1 = PARSENUMBER_OVERFLOW;
		r2 = maxresult;
		return;
	}
	else
	{
		r1 = PARSENUMBER_SUCCESS;
		r2 = result;
		return;
	}
}
	

function int atoi(str s)
{
	ParseInt(s, 10);
	return r2;
}

function fixed atof(str s)
{
	ParseFixed(s, 10);
	return r2;
}

function bool StrIsInt(str s)
{
	ParseInt(s, 10);
	return r1 != PARSENUMBER_BADFORMAT;
}

function bool StrIsFixed(str s)
{
	ParseFixed(s, 10);
	return r1 != PARSENUMBER_BADFORMAT;
}
// Actor property shorthands with network optimization.
// Idea from AOW.


/*
int Accuracy
fixed Alpha
bool Ambush
fixed AttackZOffset
bool ChaseGoal
int Damage
fixed DamageFactor
fixed DamageMultiplier
bool Dormant
bool Dropped
fixed Friction
bool Friendly
bool Frightened
fixed Gravity
int Health
fixed Height
bool Invulnerable
fixed JumpZ
int Mass
int MasterTID
fixed MaxDropOffHeight
fixed MaxStepHeight
fixed MeleeRange
bool NoTrigger
bool NoTarget
fixed Radius
int ReactionTime
int RenderStyle
fixed ScaleX
fixed ScaleY
int Score
int SpawnHealth
fixed Speed
int Stamina
int StencilColor
int TargetTID
int TracerTID
fixed ViewHeight
int Waterlevel
str DamageType
str Nametag
str Species
str ActiveSound
str AttackSound
str DeathSound
str PainSound
str SeeSound
*/

function int GetActorAccuracy(int tid) { return GetActorProperty(tid, APROP_Accuracy); }
function void SetActorAccuracy(int tid, int Accuracy)
{
	if (GetActorProperty(tid, APROP_Accuracy) != Accuracy)
		SetActorProperty(tid, APROP_Accuracy, Accuracy);
}

function fixed GetActorAlpha(int tid) { return GetActorProperty(tid, APROP_Alpha); }
function void SetActorAlpha(int tid, fixed Alpha)
{
	if (GetActorProperty(tid, APROP_Alpha) != Alpha)
		SetActorProperty(tid, APROP_Alpha, Alpha);
}

function bool GetActorAmbush(int tid) { return GetActorProperty(tid, APROP_Ambush); }
function void SetActorAmbush(int tid, bool Ambush)
{
	if (GetActorProperty(tid, APROP_Ambush) != Ambush)
		SetActorProperty(tid, APROP_Ambush, Ambush);
}

function fixed GetActorAttackZOffset(int tid) { return GetActorProperty(tid, APROP_AttackZOffset); }
function void SetActorAttackZOffset(int tid, fixed AttackZOffset)
{
	if (GetActorProperty(tid, APROP_AttackZOffset) != AttackZOffset)
		SetActorProperty(tid, APROP_AttackZOffset, AttackZOffset);
}

function bool GetActorChaseGoal(int tid) { return GetActorProperty(tid, APROP_ChaseGoal); }
function void SetActorChaseGoal(int tid, bool ChaseGoal)
{
	if (GetActorProperty(tid, APROP_ChaseGoal) != ChaseGoal)
		SetActorProperty(tid, APROP_ChaseGoal, ChaseGoal);
}

function int GetActorDamage(int tid) { return GetActorProperty(tid, APROP_Damage); }
function void SetActorDamage(int tid, int Damage)
{
	if (GetActorProperty(tid, APROP_Damage) != Damage)
		SetActorProperty(tid, APROP_Damage, Damage);
}

function fixed GetActorDamageFactor(int tid) { return GetActorProperty(tid, APROP_DamageFactor); }
function void SetActorDamageFactor(int tid, fixed DamageFactor)
{
	if (GetActorProperty(tid, APROP_DamageFactor) != DamageFactor)
		SetActorProperty(tid, APROP_DamageFactor, DamageFactor);
}

function fixed GetActorDamageMultiplier(int tid) { return GetActorProperty(tid, APROP_DamageMultiplier); }
function void SetActorDamageMultiplier(int tid, fixed DamageMultiplier)
{
	if (GetActorProperty(tid, APROP_DamageMultiplier) != DamageMultiplier)
		SetActorProperty(tid, APROP_DamageMultiplier, DamageMultiplier);
}

function bool GetActorDormant(int tid) { return GetActorProperty(tid, APROP_Dormant); }
function void SetActorDormant(int tid, bool Dormant)
{
	if (GetActorProperty(tid, APROP_Dormant) != Dormant)
		SetActorProperty(tid, APROP_Dormant, Dormant);
}

function bool GetActorDropped(int tid) { return GetActorProperty(tid, APROP_Dropped); }
function void SetActorDropped(int tid, bool Dropped)
{
	if (GetActorProperty(tid, APROP_Dropped) != Dropped)
		SetActorProperty(tid, APROP_Dropped, Dropped);
}

function fixed GetActorFriction(int tid) { return GetActorProperty(tid, APROP_Friction); }
function void SetActorFriction(int tid, fixed Friction)
{
	if (GetActorProperty(tid, APROP_Friction) != Friction)
		SetActorProperty(tid, APROP_Friction, Friction);
}

function bool GetActorFriendly(int tid) { return GetActorProperty(tid, APROP_Friendly); }
function void SetActorFriendly(int tid, bool Friendly)
{
	if (GetActorProperty(tid, APROP_Friendly) != Friendly)
		SetActorProperty(tid, APROP_Friendly, Friendly);
}

function bool GetActorFrightened(int tid) { return GetActorProperty(tid, APROP_Frightened); }
function void SetActorFrightened(int tid, bool Frightened)
{
	if (GetActorProperty(tid, APROP_Frightened) != Frightened)
		SetActorProperty(tid, APROP_Frightened, Frightened);
}

function fixed GetActorGravity(int tid) { return GetActorProperty(tid, APROP_Gravity); }
function void SetActorGravity(int tid, fixed Gravity)
{
	if (GetActorProperty(tid, APROP_Gravity) != Gravity)
		SetActorProperty(tid, APROP_Gravity, Gravity);
}

function int GetActorHealth(int tid) { return GetActorProperty(tid, APROP_Health); }
function void SetActorHealth(int tid, int Health)
{
	if (GetActorProperty(tid, APROP_Health) != Health)
		SetActorProperty(tid, APROP_Health, Health);
}

function fixed GetActorHeight(int tid) { return GetActorProperty(tid, APROP_Height); }
function void SetActorHeight(int tid, fixed Height)
{
	if (GetActorProperty(tid, APROP_Height) != Height)
		SetActorProperty(tid, APROP_Height, Height);
}

function bool GetActorInvulnerable(int tid) { return GetActorProperty(tid, APROP_Invulnerable); }
function void SetActorInvulnerable(int tid, bool Invulnerable)
{
	if (GetActorProperty(tid, APROP_Invulnerable) != Invulnerable)
		SetActorProperty(tid, APROP_Invulnerable, Invulnerable);
}

function fixed GetActorJumpZ(int tid) { return GetActorProperty(tid, APROP_JumpZ); }
function void SetActorJumpZ(int tid, fixed JumpZ)
{
	if (GetActorProperty(tid, APROP_JumpZ) != JumpZ)
		SetActorProperty(tid, APROP_JumpZ, JumpZ);
}

function fixed GetActorMass(int tid) { return GetActorProperty(tid, APROP_Mass); }
function void SetActorMass(int tid, fixed Mass)
{
	if (GetActorProperty(tid, APROP_Mass) != Mass)
		SetActorProperty(tid, APROP_Mass, Mass);
}

function int GetActorMasterTID(int tid) { return GetActorProperty(tid, APROP_MasterTID); }
function void SetActorMasterTID(int tid, int MasterTID)
{
	if (GetActorProperty(tid, APROP_MasterTID) != MasterTID)
		SetActorProperty(tid, APROP_MasterTID, MasterTID);
}

function fixed GetActorMaxDropOffHeight(int tid) { return GetActorProperty(tid, APROP_MaxDropOffHeight); }
function void SetActorMaxDropOffHeight(int tid, fixed MaxDropOffHeight)
{
	if (GetActorProperty(tid, APROP_MaxDropOffHeight) != MaxDropOffHeight)
		SetActorProperty(tid, APROP_MaxDropOffHeight, MaxDropOffHeight);
}

function fixed GetActorMaxStepHeight(int tid) { return GetActorProperty(tid, APROP_MaxStepHeight); }
function void SetActorMaxStepHeight(int tid, fixed MaxStepHeight)
{
	if (GetActorProperty(tid, APROP_MaxStepHeight) != MaxStepHeight)
		SetActorProperty(tid, APROP_MaxStepHeight, MaxStepHeight);
}

function int GetActorMeleeRange(int tid) { return GetActorProperty(tid, APROP_MeleeRange); }
function void SetActorMeleeRange(int tid, fixed MeleeRange)
{
	if (GetActorProperty(tid, APROP_MeleeRange) != MeleeRange)
		SetActorProperty(tid, APROP_MeleeRange, MeleeRange);
}

function bool GetActorNoTrigger(int tid) { return GetActorProperty(tid, APROP_NoTrigger); }
function void SetActorNoTrigger(int tid, bool NoTrigger)
{
	if (GetActorProperty(tid, APROP_NoTrigger) != NoTrigger)
		SetActorProperty(tid, APROP_NoTrigger, NoTrigger);
}

function bool GetActorNoTarget(int tid) { return GetActorProperty(tid, APROP_NoTarget); }
function void SetActorNoTarget(int tid, bool NoTarget)
{
	if (GetActorProperty(tid, APROP_NoTarget) != NoTarget)
		SetActorProperty(tid, APROP_NoTarget, NoTarget);
}

function int GetActorRadius(int tid) { return GetActorProperty(tid, APROP_Radius); }
function void SetActorRadius(int tid, fixed Radius)
{
	if (GetActorProperty(tid, APROP_Radius) != Radius)
		SetActorProperty(tid, APROP_Radius, Radius);
}

function int GetActorReactionTime(int tid) { return GetActorProperty(tid, APROP_ReactionTime); }
function void SetActorReactionTime(int tid, int ReactionTime)
{
	if (GetActorProperty(tid, APROP_ReactionTime) != ReactionTime)
		SetActorProperty(tid, APROP_ReactionTime, ReactionTime);
}

function int GetActorRenderStyle(int tid) { return GetActorProperty(tid, APROP_RenderStyle); }
function void SetActorRenderStyle(int tid, int RenderStyle)
{
	if (GetActorProperty(tid, APROP_RenderStyle) != RenderStyle)
		SetActorProperty(tid, APROP_RenderStyle, RenderStyle);
}

function int GetActorScaleX(int tid) { return GetActorProperty(tid, APROP_ScaleX); }
function void SetActorScaleX(int tid, fixed ScaleX)
{
	if (GetActorProperty(tid, APROP_ScaleX) != ScaleX)
		SetActorProperty(tid, APROP_ScaleX, ScaleX);
}

function int GetActorScaleY(int tid) { return GetActorProperty(tid, APROP_ScaleY); }
function void SetActorScaleY(int tid, fixed ScaleY)
{
	if (GetActorProperty(tid, APROP_ScaleY) != ScaleY)
		SetActorProperty(tid, APROP_ScaleY, ScaleY);
}

function int GetActorScore(int tid) { return GetActorProperty(tid, APROP_Score); }
function void SetActorScore(int tid, int Score)
{
	if (GetActorProperty(tid, APROP_Score) != Score)
		SetActorProperty(tid, APROP_Score, Score);
}

function int GetActorSpawnHealth(int tid) { return GetActorProperty(tid, APROP_SpawnHealth); }
function void SetActorSpawnHealth(int tid, int SpawnHealth)
{
	if (GetActorProperty(tid, APROP_SpawnHealth) != SpawnHealth)
		SetActorProperty(tid, APROP_SpawnHealth, SpawnHealth);
}

function int GetActorSpeed(int tid) { return GetActorProperty(tid, APROP_Speed); }
function void SetActorSpeed(int tid, fixed Speed)
{
	if (GetActorProperty(tid, APROP_Speed) != Speed)
		SetActorProperty(tid, APROP_Speed, Speed);
}

function int GetActorStamina(int tid) { return GetActorProperty(tid, APROP_Stamina); }
function void SetActorStamina(int tid, int Stamina)
{
	if (GetActorProperty(tid, APROP_Stamina) != Stamina)
		SetActorProperty(tid, APROP_Stamina, Stamina);
}

function int GetActorStencilColor(int tid) { return GetActorProperty(tid, APROP_StencilColor); }
function void SetActorStencilColor(int tid, int StencilColor)
{
	if (GetActorProperty(tid, APROP_StencilColor) != StencilColor)
		SetActorProperty(tid, APROP_StencilColor, StencilColor);
}

function int GetActorTargetTID(int tid) { return GetActorProperty(tid, APROP_TargetTID); }
function void SetActorTargetTID(int tid, int TargetTID)
{
	if (GetActorProperty(tid, APROP_TargetTID) != TargetTID)
		SetActorProperty(tid, APROP_TargetTID, TargetTID);
}

function int GetActorTracerTID(int tid) { return GetActorProperty(tid, APROP_TracerTID); }
function void SetActorTracerTID(int tid, int TracerTID)
{
	if (GetActorProperty(tid, APROP_TracerTID) != TracerTID)
		SetActorProperty(tid, APROP_TracerTID, TracerTID);
}

// GetActorViewHeight is native
function void SetActorViewHeight(int tid, fixed ViewHeight)
{
	if (GetActorProperty(tid, APROP_ViewHeight) != ViewHeight)
		SetActorProperty(tid, APROP_ViewHeight, ViewHeight);
}

function int GetActorWaterlevel(int tid) { return GetActorProperty(tid, APROP_Waterlevel); }
function void SetActorWaterlevel(int tid, int Waterlevel)
{
	if (GetActorProperty(tid, APROP_Waterlevel) != Waterlevel)
		SetActorProperty(tid, APROP_Waterlevel, Waterlevel);
}

// String properties.
function str GetActorDamageType(int tid) { return GetActorProperty(tid, APROP_DamageType); }
function void SetActorDamageType(int tid, str DamageType)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_DamageType), DamageType))
		SetActorProperty(tid, APROP_DamageType, DamageType);
}

function str GetActorNametag(int tid) { return GetActorProperty(tid, APROP_Nametag); }
function void SetActorNametag(int tid, str Nametag)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_Nametag), Nametag))
		SetActorProperty(tid, APROP_Nametag, Nametag);
}

function str GetActorSpecies(int tid) { return GetActorProperty(tid, APROP_Species); }
function void SetActorSpecies(int tid, str Species)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_Species), Species))
		SetActorProperty(tid, APROP_Species, Species);
}

function str GetActorActiveSound(int tid) { return GetActorProperty(tid, APROP_ActiveSound); }
function void SetActorActiveSound(int tid, str ActiveSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_ActiveSound), ActiveSound))
		SetActorProperty(tid, APROP_ActiveSound, ActiveSound);
}

function str GetActorAttackSound(int tid) { return GetActorProperty(tid, APROP_AttackSound); }
function void SetActorAttackSound(int tid, str AttackSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_AttackSound), AttackSound))
		SetActorProperty(tid, APROP_AttackSound, AttackSound);
}

function str GetActorDeathSound(int tid) { return GetActorProperty(tid, APROP_DeathSound); }
function void SetActorDeathSound(int tid, str DeathSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_DeathSound), DeathSound))
		SetActorProperty(tid, APROP_DeathSound, DeathSound);
}

function str GetActorPainSound(int tid) { return GetActorProperty(tid, APROP_PainSound); }
function void SetActorPainSound(int tid, str PainSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_PainSound), PainSound))
		SetActorProperty(tid, APROP_PainSound, PainSound);
}

function str GetActorSeeSound(int tid) { return GetActorProperty(tid, APROP_SeeSound); }
function void SetActorSeeSound(int tid, str SeeSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_SeeSound), SeeSound))
		SetActorProperty(tid, APROP_SeeSound, SeeSound);
}


function bool IsPlayer(void)
{
	return PlayerNumber() >= 0;
}

script "ACSUtils_ActorPlayerNumber" (int tid)
{
	SetActivator(tid);
	SetResultValue(PlayerNumber());
}

function int ActorPlayerNumber(int tid)
{
	return ACS_NamedExecuteWithResult("ACSUtils_ActorPlayerNumber", tid);
}

function bool ActorIsPlayer(int tid)
{
	return bool(ClassifyActor(tid) & ACTOR_PLAYER);
}

function str PlayerName(int player)
{
	return StrParam(n:player + 1);
}

function int GetPlayerTeam(int player)
{
	return GetPlayerInfo(player, PLAYERINFO_TEAM);
}

function int TeamPlayerCount(int team)
{
	return GetTeamProperty(team, TPROP_NumPlayers);
}


// ConsolePlayer stuff
function bool ConsolePlayerInGame(void)
{
	return PlayerInGame(ConsolePlayerNumber());
}

function str ConsolePlayerName(void)
{
	return PlayerName(ConsolePlayerNumber());
}

function int ConsolePlayerTeam(void)
{
	return GetPlayerTeam(ConsolePlayerNumber());
}

function bool SetActivatorToConsolePlayer(void)
{
	return SetActivatorToPlayer2(ConsolePlayerNumber());
}


function bool SetActivatorToPlayer2(int player)
{
	if (SetActivatorToPlayer(player))
		return true;
		
	if (player >= 0 && player < 8)
		return false;
		
	return SetActivator(0, AAPTR_PLAYER1<<player);
}


// PlayerIsBot is native

function bool PlayerIsConnected(int player)
{
	return PlayerInGame(player) || PlayerIsSpectator(player);
}

function bool PlayerIsDeadSpectator(int player)
{
	return (raw)PlayerIsSpectator(player) == 2;
}

// PlayerInGame is native

// PlayerIsSpectator is native


function int BotCount(void)
{
	int count = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsBot(i))
			count++;
	return count;
}

function int ClientCount(void)
{
	int count = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsConnected(i))
			count++;
	return count;
}

function int DeadSpectatorCount(void)
{
	int count = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsDeadSpectator(i))
			count++;
	return count;
}

// PlayerCount is native

function int SpectatorCount(void)
{
	int count = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsSpectator(i))
			count++;
	return count;
}


int ACSUtils_Players[MAX_PLAYERS];

function int PickRandomBot(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsBot(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

function int PickRandomClient(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsConnected(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

function int PickRandomDeadSpectator(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsDeadSpectator(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

function int PickRandomPlayer(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerInGame(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

function int PickRandomSpectator(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsSpectator(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

function int PickRandomTeamPlayer(int team)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerInGame(i) && GetPlayerTeam(i) == team)
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}


















	

function fixed CursorX(void)
{
	return ACSUtils_Ints[35];
}

function fixed CursorY(void)
{
	return ACSUtils_Ints[0];
}

function fixed CursorDeltaX(void)
{
	if (ACSUtils_Ints[8])
		return CursorMotionX();
	return ACSUtils_Ints[35] - ACSUtils_Ints[16];
}
function fixed CursorDeltaY(void)
{
	if (ACSUtils_Ints[43])
		return CursorMotionY();
	return ACSUtils_Ints[0] - ACSUtils_Ints[47];
}

function fixed CursorMotionX(void)
{
	return ACSUtils_Ints[29];
}

function fixed CursorMotionY(void)
{
	return ACSUtils_Ints[38];
}

function void SetCursorSpeed(fixed speed)
{
	ACSUtils_Ints[31] = speed;
	ACSUtils_Ints[7] = speed;
}

function void SetCursorSpeedX(fixed speed)
{
	ACSUtils_Ints[31] = speed;
}

function void SetCursorSpeedY(fixed speed)
{
	ACSUtils_Ints[7] = speed;
}

function void SetCursorPosition(fixed x, fixed y)
{
	ACSUtils_Ints[35] = x;
	ACSUtils_Ints[0] = y;
}

function void CenterCursor(void)
{
	SetCursorPosition(ACSUtils_Ints[53] / 2, ACSUtils_Ints[2] / 2);
}

function void EnableCursorWrap(bool enable)
{
	ACSUtils_Ints[8] = enable;
	ACSUtils_Ints[43] = enable;
}

function void EnableCursorWrapX(bool enable)
{
	ACSUtils_Ints[8] = enable;
}

function void EnableCursorWrapY(bool enable)
{
	ACSUtils_Ints[43] = enable;
}

function void ACSUtils_ClampCursor(void)
{
	fixed width = ACSUtils_Ints[53];
	fixed height = ACSUtils_Ints[2];
	
	fixed borderX = HudBorderXFor(width);
	fixed borderY = HudBorderYFor(height);
	
	ACSUtils_Ints[35] += borderX;
	ACSUtils_Ints[0] += borderY;
	
	width +=  (fixed)((int)(borderX) * 2);
	height += (fixed)((int)(borderY) * 2);

	if (ACSUtils_Ints[8])
		ACSUtils_Ints[35] = mod(ACSUtils_Ints[35], width);
	else
		ACSUtils_Ints[35] = clamp(ACSUtils_Ints[35], 0, width);
	
	if (ACSUtils_Ints[43])
		ACSUtils_Ints[0] = mod(ACSUtils_Ints[0], height);
	else
		ACSUtils_Ints[0] = clamp(ACSUtils_Ints[0], 0, height);
		
	ACSUtils_Ints[35] -= borderX;
	ACSUtils_Ints[0] -= borderY;
}

function void SetCursorArea(fixed width, fixed height)
{
	if (width <= 0.0)
		ACSUtils_ProgramError(StrParam(s:"Cursor area width set to ", f:width));
	if (height <= 0.0)
		ACSUtils_ProgramError(StrParam(s:"Cursor area height set to ", f:height));
	
	ACSUtils_Ints[35] = FixedMul(ACSUtils_Ints[35], FixedDiv(width, ACSUtils_Ints[53]));
	ACSUtils_Ints[0] = FixedMul(ACSUtils_Ints[0], FixedDiv(height, ACSUtils_Ints[2]));
	ACSUtils_Ints[16] = FixedMul(ACSUtils_Ints[16], FixedDiv(width, ACSUtils_Ints[53]));
	ACSUtils_Ints[47] = FixedMul(ACSUtils_Ints[47], FixedDiv(height, ACSUtils_Ints[2]));
	ACSUtils_Ints[29] = FixedMul(ACSUtils_Ints[29], FixedDiv(width, ACSUtils_Ints[53]));
	ACSUtils_Ints[38] = FixedMul(ACSUtils_Ints[38], FixedDiv(height, ACSUtils_Ints[2]));

	ACSUtils_Ints[53] = width;
	ACSUtils_Ints[2] = height;
}

function void UpdateCursor(void)
{
	ACSUtils_Ints[16] = ACSUtils_Ints[35];
	ACSUtils_Ints[47] = ACSUtils_Ints[0];

	fixed sensitivity = a_GetCVarFixed("mouse_sensitivity");
	fixed speedX = FixedDiv(ACSUtils_Ints[31], FixedMul(a_GetCVarFixed("m_yaw"), sensitivity));
	fixed speedY = FixedDiv(ACSUtils_Ints[7], FixedMul(a_GetCVarFixed("m_pitch"), sensitivity));
	
	speedX = (fixed)((int)(FixedMul((fixed)((int)(speedX) * 2), ACSUtils_Ints[53])) / 64000);
	speedY = (fixed)((int)(FixedMul((fixed)((int)(speedY) * 2), ACSUtils_Ints[2])) / 32000);

	fixed dx = (fixed)(-GetPlayerInput(ConsolePlayerNumber(), INPUT_YAW)   * (int)(speedX));
    fixed dy = (fixed)(-GetPlayerInput(ConsolePlayerNumber(), INPUT_PITCH) * (int)(speedY));

	if (GetCVar("invertmouse"))
        dy = -dy;
		
	ACSUtils_Ints[29] = dx;
	ACSUtils_Ints[38] = dy;
	ACSUtils_Ints[35] += dx;
	ACSUtils_Ints[0] += dy;
	ACSUtils_ClampCursor();
}

enum : int { PORT_ZDOOM = 1 };
enum : int { PORT_GZDOOM = 2 };
enum : int { PORT_ZANDRONUM = 3 };



// Port identification methods copied from ACS-X
function int IdentifySourcePort(void)
{
	if (ACSUtils_Ints[4] != -1)
		return ACSUtils_Ints[4];

	if (GetPlayerAccountName(0) != (raw)0)
	{
		// GetPlayerAccountName returns a string (possibly empty) in Zandronum
		// but 0 in GZDoom.
		ACSUtils_Ints[4] = PORT_ZANDRONUM;
		return ACSUtils_Ints[4];
	}
	
	int tid = UniqueTid();
	if (SpawnForced("DynamicLight", 0.0, 0.0, 0.0, tid))
	{
		// DynamicLight is a built-in actor in GZDoom.
		Thing_Remove(tid);
		ACSUtils_Ints[4] = PORT_GZDOOM;
		return ACSUtils_Ints[4];
	}
	
	ACSUtils_Ints[4] = PORT_ZDOOM;
	return ACSUtils_Ints[4];
}

function str GetPortName(void)
{
	int port = IdentifySourcePort();
	switch (port)
	{
	case PORT_ZDOOM:
		return "ZDoom";
	case PORT_GZDOOM:
		return "GZDoom";
	case PORT_ZANDRONUM:
		return "Zandronum";
	}

	return StrParam(s:"IdentifySourcePort() returned ", d:port);
}

function bool IsZandronum(void)
{
	return IdentifySourcePort() == PORT_ZANDRONUM;
}

function bool IsGZDoom(void)
{
	int port = IdentifySourcePort();
	return port == PORT_GZDOOM || port == PORT_ZANDRONUM;
}

function bool IsServer(void)
{
	if (ConsolePlayerNumber() < 0)
		return true;
		
	// Needs to be done like this to avoid crashing the script in ZDoom.
	if (IsZandronum())
		return !IsNetworkGame();
	
	return true;
}

function bool IsClient(void)
{
	return ConsolePlayerNumber() >= 0;
}

function bool IsServerOnly(void)
{
	return IsServer() && !IsClient();
}

function bool IsClientOnly(void)
{
	return IsClient() && !IsServer();
}

function bool IsOpenGL(void)
{
	if (!IsClient())
	{
		ACSUtils_ProgramError("IsOpenGL() used serverside. Assuming OpenGL renderer.");
		return true; // OpenGL generally has less limitations.
	}
	
	// Correctly identifies ZDoom with a config file from GZDoom with vid_renderer = 1.
	if (IsGZDoom())
		return GetCVar("vid_renderer") == 1 && GetCVar("gl_nogl") == 0;
	
	return false;
}

// Most of this file is written by carlcyber and bagheadspidey.
// See http://forum.zdoom.org/viewtopic.php?f=3&t=35383
// Interface 

// BCC type
enum : fixed { ASPECT_4_3 = (fixed)((int)(4.0) / 3) };
enum : fixed { ASPECT_5_4 = 1.25 };
enum : fixed { ASPECT_16_9 = (fixed)((int)(16.0) / 9) };
enum : fixed { ASPECT_16_10 = 1.6 };
enum : fixed { ASPECT_17_10 = 1.7 };

function fixed GetAspectRatio(void)
{
	if (!IsClient())
	{
		ACSUtils_ProgramError("GetAspectRatio() called serverside. Assuming 4:3.");
		return ASPECT_4_3;
	}

	raw width = GetCVar("vid_defwidth");
	raw height = GetCVar("vid_defheight");
	raw nowidescreen = GetCVar("vid_nowidescreen");
	raw tft = GetCVar("vid_tft");
	raw aspect = GetCVar("vid_aspect");
	switch(aspect)
	{
		case 1:	return ASPECT_16_9;
		case 2:	return ASPECT_16_10;
		case 3:	return ASPECT_4_3;
		case 4:	return ASPECT_5_4;
		case 5: return ASPECT_17_10;
	}
	if(nowidescreen)
	{
		if(!tft)
			return ASPECT_4_3;
		if(height * ASPECT_5_4 == width<<16)
			return ASPECT_5_4;
		else
			return ASPECT_4_3;
	}
	if(abs((abs(height * ASPECT_16_9)>>16) - width) < 10)
	{
		return ASPECT_16_9;
	}
	if(abs((abs(height * ASPECT_17_10)>>16) - width) < 10)
	{
		return ASPECT_17_10;
	}
	if(abs((abs(height * ASPECT_16_10)>>16) - width) < 60)
	{
		if((width == 320 && height == 200) || (width == 640 && height == 400))
			return ASPECT_4_3;
		return ASPECT_16_10;
	}
	if((height * ASPECT_5_4)>>16 == width && tft)
	{
		return ASPECT_5_4;
	}
	return ASPECT_4_3;
}

/*
 * Gets the borders of the specified HUD size.
 * [NOTE]:
 *     1. The HUD borders are written in HudLeft, HudRight, HudTop, and HudBottom variables.
 *     2. Status bar and small screen blocks (screenblocks < 11) are not supported.
 * [Credit]
 *    Original HUD edge positioning functions by bagheadspidey
 */

function fixed HudBorderXFor(fixed width)
{
	fixed ar = GetAspectRatio();
	switch (ar)
	{
		case ASPECT_4_3: return 0.0;
		case ASPECT_16_9: return (fixed)((int)(width) / 6);
		case ASPECT_16_10: return (fixed)((int)(width) / 10);
		case ASPECT_17_10: return (fixed)((int)(width) / 80);
	}
	return 0.0;
}

function fixed HudBorderYFor(fixed height)
{
	if (GetAspectRatio() == ASPECT_5_4)
		return (fixed)((int)(height) / 30);
	return 0.0;
}

function fixed HudLeftFor(fixed width)
{
	return -HudBorderXFor(width);
}
function fixed HudX1For(fixed width)
{
	return -HudBorderXFor(width);
}

function fixed HudRightFor(fixed width)
{
	return width + HudBorderXFor(width);
}
function fixed HudX2For(fixed width)
{
	return width + HudBorderXFor(width);
}


function fixed HudTopFor(fixed height)
{
	return -HudBorderYFor(height);
}
function fixed HudY1For(fixed height)
{
	return -HudBorderYFor(height);
}

function fixed HudBottomFor(fixed height)
{
	return height + HudBorderYFor(height);
}
function fixed HudY2For(fixed height)
{
	return height + HudBorderYFor(height);
}

// Contributed to ACSUtils by Konda

// Sorts an array, given the named scripts for comparing and swapping array elements
function void SortArray(int begin_index, int end_index, str less_than, str cb_swap)
{
    ACSUtils_heap_sort(begin_index, end_index - 1, less_than, cb_swap);
    //_selection_sort(begin_index, end_index - 1, less_than, cb_swap);
}

/*
function void _selection_sort(int begin, int end, str lt, str cb_swap)
{
    for(int i = begin; i <= end-1; i++)
    for(int j = i+1; j <= end; j++)
        if(ACS_NamedExecuteWithResult(lt, j, i))
            ACS_NamedExecuteWithResult(cb_swap, j, i);
}
*/

function void ACSUtils_heap_sort(int begin, int end, str lt, str cb_swap)
{
    if(begin >= end) return;
    int heap_size;
    
    // Since the supplied comparison function is a min function, we build a max heap to finally cb_swap the max with the last element in the array range
    ACSUtils_build_max_heap(begin, end, lt, cb_swap);
    
    // At this point in execution the heap size will be >= 2
    do
    {
        // Protip: use ExecuteWithResult even when ur not expecting a result, otherwise the execution order will be fucked up if a script is called from inside a function (i almost ragequit acs again until i figured this out)
        //Log(s:"Imma cb_swap yo momma");
        ACS_NamedExecuteWithResult(cb_swap, begin, end);
        heap_size = --end - begin + 1;
        
        // There's only a single violation of the max-heap property - at the root of the entire heap, from now on
        ACSUtils_max_heapify(begin, begin, end, lt, cb_swap);
    }
    while(heap_size > 1);
}

// Reorders the entire array range to establish the max-heap invariant
function void ACSUtils_build_max_heap(int begin, int end, str lt, str cb_swap)
{
    // i = n/2 downto 1 inclusive, for arrays whose indexing is in range 1..n
    for(int i = begin + (end - begin) / 2; i >= begin; i--)
        ACSUtils_max_heapify(i, begin, end, lt, cb_swap);
}

// Corrects a single violation of the max-heap property at the given index, continuing to one of its subtrees after correction
function void ACSUtils_max_heapify(int index, int begin, int end, str lt, str cb_swap)
{
    // Implemented as 2 functions to avoid recursion, just in case of some acs shitrestriction
    do
    {
        index = ACSUtils_max_heapify_step(index, begin, end, lt, cb_swap);
    }
    while(index != -1);
}

// Returns index of the next subtree to be checked for the max-heap property and corrected; Returns -1 when done
function int ACSUtils_max_heapify_step(int index, int begin, int end, str lt, str cb_swap)
{
    int lchild = ACSUtils_heap_lchild(index, begin);
    int rchild = ACSUtils_heap_rchild(index, begin);
    
    // Check the max-heap property for the subtree rooted at _index_
    int max_i = index;
    if((lchild <= end) && ACS_NamedExecuteWithResult(lt, max_i, lchild))
        max_i = lchild;
    if((rchild <= end) && ACS_NamedExecuteWithResult(lt, max_i, rchild))
        max_i = rchild;
    if(max_i != index)
    {
        ACS_NamedExecuteWithResult(cb_swap, index, max_i);
        return max_i;
    }
    return -1;
}

// Heap node children index functions
function int ACSUtils_heap_lchild(int index, int begin)
{
    return begin + 2*(index - begin);
}

function int ACSUtils_heap_rchild(int index, int begin)
{
    return begin + 2*(index - begin) + 1;
}

// Contributed to ACSUtils by Konda

function void ShuffleArray(int begin, int end, str cb_swap)
{
	end--;
    for(int pick = begin; pick < end; pick++)
    {
        int index = random(pick, end);
        if(index != pick)
            ACS_NamedExecuteWithResult(cb_swap, pick, index);
    }
}

function void SyncVariable(int tid, raw value)
{
	if (ClassifyActor(tid) == ACTOR_NONE)
	{
		if (!SpawnForced("ACSUtils_Sync", 0.0, 0.0, 0.0, tid))	
		{
			ACSUtils_ProgramError(StrParam
			(
				s:"Failed to spawn sync actor for tid ", d:tid, s:". ",
				s:"Make sure you copied \cjdecorate.acsutils \c-to your project."
			));
		}
	}
					
	SetActorProperty(tid, APROP_SPEED, value);
}

function raw GetSyncVar(int tid)
{
	return GetActorProperty(tid, APROP_SPEED);
}

function raw GetSyncVarDefault(int tid, raw default_value)
{
	if (ClassifyActor(tid) == ACTOR_NONE)
		return default_value;
	return GetActorProperty(tid, APROP_SPEED);
}

// When adding new properties, don't forget to edit ACSUTILS_HUDSTATE_SIZE.
private enum : int { ACSUTILS_HUDLIB_SAVEDSTATES = 16 };
private enum : int { ACSUTILS_HUDSTATE_SIZE = 39 };
private enum : int { ACSUTILS_HUDLIB_STACKSIZE = ACSUTILS_HUDSTATE_SIZE * ACSUTILS_HUDLIB_SAVEDSTATES };



















































	

	



	
	





function void HudResetState(void)
{
	ACSUtils_Ints[52] = false;


	ACSUtils_Ints[19] = 0.0;
	ACSUtils_Ints[9] = 0.0;
	ACSUtils_Ints[40] = 0.0;
	ACSUtils_Ints[28] = 0.0;
	ACSUtils_Ints[11] = 0.0;

	ACSUtils_Ints[32] = 0.0;
	ACSUtils_Ints[15] = 0.0;
	ACSUtils_Ints[20] = 0.0;

	ACSUtils_Ints[12] = 0.0;
	ACSUtils_Ints[21] = 0.0;

	ACSUtils_Ints[42] = true;
	ACSUtils_Ints[17] = HUD_PROJECTION_AUTO;

	ACSUtils_Ints[23] = 640.0;
	ACSUtils_Ints[46] = 480.0;
	ACSUtils_Ints[45] = false;

	ACSUtils_Ints[41] = 0.0;
	ACSUtils_Ints[18] = 0.0;

	ACSUtils_Ints[30] = 1.0;
	ACSUtils_Ints[51] = 1.0;

	ACSUtils_Ints[37] = false;

	ACSUtils_Ints[5] = 0.0;
	ACSUtils_Ints[6] = HUD_STAYTIME_FOREVER;
	ACSUtils_Ints[48] = 0.0;

	ACSUtils_Ints[39] = HUD_BLENDSTYLE_NORMAL;
	ACSUtils_Ints[25] = 1.0;

	ACSUtils_Ints[24] = true;
	ACSUtils_Ints[50] = true;
	ACSUtils_Ints[34] = true;

	ACSUtils_Ints[27] = HUDMSG_LAYER_OVERHUD;

	ACSUtils_Ints[13] = HUD_ALIGN_CENTER;
	ACSUtils_Ints[49] = HUD_ALIGN_CENTER;
	ACSUtils_Ints[26] = false;
	ACSUtils_Strings[0] = "SMALLFONT";
	ACSUtils_Ints[1] = false;
	ACSUtils_Ints[3] = CR_UNTRANSLATED;
	ACSUtils_Ints[54] = false;
	ACSUtils_Ints[33] = false;
	ACSUtils_Ints[10] = false;
}

raw HudStateStack[ACSUTILS_HUDLIB_STACKSIZE];

function void HudClearStateStack(void)
{
	ACSUtils_Ints[36] = 0;
}

function void HudPushState(void)
{
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[52];


	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[19];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[9];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[40];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[28];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[11];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[32];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[15];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[20];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[12];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[21];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[42];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[17];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[23];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[46];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[45];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[41];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[18];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[30];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[51];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[37];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[5];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[6];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[48];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[39];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[25];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[24];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[50];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[34];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[27];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[13];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[49];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[26];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Strings[0];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[1];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[3];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[54];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[33];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[10];
	
	if (ACSUtils_Ints[36] > ACSUTILS_HUDLIB_STACKSIZE)
		ACSUtils_LimitError("HudPushState(): state stack overflow.");
}

function void HudPopState(void)
{
	if (ACSUtils_Ints[36] == 0)
	{
		ACSUtils_ProgramError("HudPopState() called with no saved state.");
		return;
	}

	ACSUtils_Ints[10] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[33] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[54] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[3] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[1] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Strings[0] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[26] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[49] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[13] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[27] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[34] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[50] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[24] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[25] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[39] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[48] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[6] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[5] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[37] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[51] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[30] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[18] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[41] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[45] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[46] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[23] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[17] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[42] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[21] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[12] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[20] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[15] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[32] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[11] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[28] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[40] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[9] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[19] = HudStateStack[--ACSUtils_Ints[36]];


	ACSUtils_Ints[52] = HudStateStack[--ACSUtils_Ints[36]];
	
	if (ACSUtils_Ints[36] < 0)
		ACSUtils_ProgramError("HudPushState/HudPopState are bugged. Report this bug to the acsutils project.");
}

function void HudSetCameraPosition(fixed x, fixed y, fixed z)
{
	ACSUtils_Ints[19] = x;
	ACSUtils_Ints[9] = y;
	ACSUtils_Ints[40] = z;
}

function void HudSetCameraAngles(fixed angle, fixed pitch)
{
	ACSUtils_Ints[28] = angle;
	ACSUtils_Ints[11] = pitch;
}

function void HudSetCameraVector(fixed x, fixed y, fixed z)
{
	VectorToAngles(x, y, z);
	ACSUtils_Ints[28] = r1;
	ACSUtils_Ints[11] = r2;
}


enum : int { HUD_CAMERAACTOR_NOPOSITION = 1 };
enum : int { HUD_CAMERAACTOR_NOPREDICTION = 2 };
enum : int { HUD_CAMERAACTOR_NODIRECTION = 4 };
enum : int { HUD_CAMERAACTOR_NOVIEWHEIGHT = 8 };

function void HudSetCameraActorAdvanced(int tid, int flags)
{
	if (!(flags & HUD_CAMERAACTOR_NOPOSITION))
	{
		fixed x = GetActorX(tid);
		fixed y = GetActorY(tid);
		fixed z = GetActorZ(tid);
		
		if (!(flags & HUD_CAMERAACTOR_NOVIEWHEIGHT))
			z += GetActorViewHeight(tid);
		
		if (!(flags & HUD_CAMERAACTOR_NOPREDICTION))
		{
			x -= GetActorVelX(tid);
			y -= GetActorVelY(tid);
			z -= GetActorVelZ(tid);
		}	
		
		HudSetCameraPosition(x, y, z);
	}
	
	if (!(flags & HUD_CAMERAACTOR_NODIRECTION))
		HudSetCameraAngles(GetActorAngle(tid), -GetActorPitch(tid));
}

function void HudSetCameraActor(int tid)
{
	HudSetCameraActorAdvanced(tid, 0);
}

function void HudSetPoint3D(fixed x, fixed y, fixed z)
{
	ACSUtils_Ints[52] = true;
	ACSUtils_Ints[32] = x;
	ACSUtils_Ints[15] = y;
	ACSUtils_Ints[20] = z;
}

function void HudSet2DOffset(fixed x, fixed y)
{
	ACSUtils_Ints[12] = x;
	ACSUtils_Ints[21] = y;
}

function void HudSetAutoDistanceScale(bool autoDistanceScale)
{
	ACSUtils_Ints[42] = autoDistanceScale;
}

function void HudSetProjectionMode(int mode)
{
	ACSUtils_Ints[17] = mode;
}

function void HudSetVirtualSize(fixed width, fixed height)
{
	ACSUtils_Ints[23] = width;
	ACSUtils_Ints[46] = height;
}

function void HudUseDefaultSize(void)
{
	ACSUtils_Ints[23] = 640.0;
	ACSUtils_Ints[46] = 480.0;
}

function void HudUseRealSize(void)
{
	ACSUtils_Ints[23] = (fixed)(GetScreenWidth()<<16);
	ACSUtils_Ints[46] = (fixed)(GetScreenHeight()<<16);
}

function fixed HudBorderX(void)
{
	return HudBorderXFor(ACSUtils_Ints[23]);
}

function fixed HudBorderY(void)
{
	return HudBorderXFor(ACSUtils_Ints[46]);
}

function fixed HudLeft(void)
{
	return HudLeftFor(ACSUtils_Ints[23]);
}
function fixed HudX1(void)
{
	return HudX1For(ACSUtils_Ints[23]);
}

function fixed HudRight(void)
{
	return HudRightFor(ACSUtils_Ints[23]);
}
function fixed HudX2(void)
{
	return HudX2For(ACSUtils_Ints[23]);
}

function fixed HudTop(void)
{
	return HudTopFor(ACSUtils_Ints[46]);
}
function fixed HudY1(void)
{
	return HudY1For(ACSUtils_Ints[46]);
}

function fixed HudBottom(void)
{
	return HudBottomFor(ACSUtils_Ints[46]);
}
function fixed HudY2(void)
{
	return HudY2For(ACSUtils_Ints[46]);
}

function void HudSetExcludeStatusBar(bool exclude)
{
	ACSUtils_Ints[45] = exclude;
}

function void HudSetPoint(fixed x, fixed y)
{
	ACSUtils_Ints[52] = false;
	ACSUtils_Ints[41] = x;
	ACSUtils_Ints[18] = y;
}

function void HudSetScaleXY(fixed scaleX, fixed scaleY)
{
	if (scaleX != 0.0)
		ACSUtils_Ints[30] = FixedDiv(1.0, scaleX);
	else
		ACSUtils_Ints[30] = 0.0;
	
	if (scaleY != 0.0)
		ACSUtils_Ints[51] = FixedDiv(1.0, scaleY);
	else
		ACSUtils_Ints[51] = 0.0;
}

function void HudSetScale(fixed scale)
{
	HudSetScaleXY(scale, scale);
}

function void HudSetInvScale(fixed invScale)
{
	ACSUtils_Ints[30] = invScale;
	ACSUtils_Ints[51] = invScale;
}

function void HudSetInvScaleXY(fixed invScaleX, fixed invScaleY)
{
	ACSUtils_Ints[30] = invScaleX;
	ACSUtils_Ints[51] = invScaleY;
}

function void HudSetShowToEveryone(bool showToEveryone)
{
	ACSUtils_Ints[37] = showToEveryone;
}

function void HudSetAppearTime(fixed appearTime)
{
	ACSUtils_Ints[5] = appearTime;
}

function void HudSetStayTime(fixed stayTime)
{
	ACSUtils_Ints[6] = stayTime;
}

function void HudSetDisappearTime(fixed disappearTime)
{
	ACSUtils_Ints[48] = disappearTime;
}

function void HudSetBlendStyle(int style)
{
	ACSUtils_Ints[39] = style;
}

function void HudSetAlpha(fixed alpha)
{
	ACSUtils_Ints[25] = alpha;
}

function void HudSetShowIn3DView(bool show)
{
	ACSUtils_Ints[24] = show;
}

function void HudSetShowOnFullAutomap(bool show)
{
	ACSUtils_Ints[50] = show;
}

function void HudSetShowOnOverlayAutomap(bool show)
{
	ACSUtils_Ints[34] = show;
}

function void HudSetLayer(int layer)
{
	ACSUtils_Ints[27] = layer;
}

function void HudSetFont(str font)
{
	ACSUtils_Strings[0] = font;
}

function void HudSetTextColor(int textColor)
{
	ACSUtils_Ints[1] = false;
	ACSUtils_Ints[3] = textColor;
}

function void HudSetTextColorString(str textColor)
{
	ACSUtils_Ints[1] = true;
	ACSUtils_Ints[3] = textColor;
}

function void HudSetCenterText(bool centerText)
{
	ACSUtils_Ints[26] = centerText;
}

function void HudSetAlignment(fixed alignX, fixed alignY)
{
	ACSUtils_Ints[13] = alignX;
	ACSUtils_Ints[49] = alignY;
}

function void HudSetAlign(fixed alignX, fixed alignY)
{
	ACSUtils_Ints[13] = alignX;
	ACSUtils_Ints[49] = alignY;
}

function void HudSetAlignmentX(fixed alignX)
{
	ACSUtils_Ints[13] = alignX;
}

function void HudSetAlignX(fixed alignX)
{
	ACSUtils_Ints[13] = alignX;
}

function void HudSetAlignmentY(fixed alignY)
{
	ACSUtils_Ints[49] = alignY;
}

function void HudSetAlignY(fixed alignY)
{
	ACSUtils_Ints[49] = alignY;
}

function void HudSetTextTypeOn(bool textTypeOn)
{
	ACSUtils_Ints[54] = textTypeOn;
}

function void HudSetLogMessage(bool logMessage)
{
	ACSUtils_Ints[33] = logMessage;
}

function void HudSetWordWrap(bool wordWrap)
{
	ACSUtils_Ints[10] = wordWrap;
}

//int ACSUtils_Ints[14];
//int ACSUtils_Ints[44];
//int ACSUtils_Ints[22];

function bool ACSUtils_IsYShearing(void)
{
	if (ACSUtils_Ints[17] == HUD_PROJECTION_AUTO)
		return !IsOpenGL();
	
	return ACSUtils_Ints[17] == HUD_PROJECTION_YSHEARING;
}

// Rotate 3D point to view coordinate system.
function void ACSUtils_HudRotate3DPoint(void)
{
	// Translated point coordinates.
	fixed x = ACSUtils_Ints[32] - ACSUtils_Ints[19];
	fixed y = ACSUtils_Ints[15] - ACSUtils_Ints[9];
	fixed z = ACSUtils_Ints[20] - ACSUtils_Ints[40];

	fixed rx, ry, rz;
	fixed s, c;

	// Rotate around Z axis.
	s = sin(-ACSUtils_Ints[28]);
	c = cos(-ACSUtils_Ints[28]);
	rx = FixedMul(x, c) - FixedMul(y, s);
	ry = FixedMul(x, s) + FixedMul(y, c);
	x = rx; y = ry;

	// Rotate around Y axis.
	if (!ACSUtils_IsYShearing())
	{
		s = sin(-ACSUtils_Ints[11]);
		c = cos(-ACSUtils_Ints[11]);
		rx = FixedMul(x, c) - FixedMul(z, s);
		rz = FixedMul(x, s) + FixedMul(z, c);
		x = rx; z = rz;
	}

	ACSUtils_Ints[14] = x;
	ACSUtils_Ints[44] = y;
	ACSUtils_Ints[22] = z;
}

function int HudGetDistance(void)
{
	ACSUtils_HudRotate3DPoint();
	return ACSUtils_Ints[14];
}


enum : int { CAMERA_BASE_DISTANCE = 128 };

function void ACSUtils_HudDrawHudMessage(int id, int type, str text, bool isText)
{
	if (ACSUtils_Ints[30] == 0 || ACSUtils_Ints[51] == 0)
		return;

	type |= ACSUtils_Ints[27];
	if (!ACSUtils_Ints[24])
		type |= HUDMSG_NOTWITH3DVIEW;
	if (!ACSUtils_Ints[50])
		type |= HUDMSG_NOTWITHFULLMAP;
	if (!ACSUtils_Ints[34])
		type |= HUDMSG_NOTWITHOVERLAYMAP;
	
	if (ACSUtils_Ints[39] == HUD_BLENDSTYLE_ADDITIVE)
		type |= HUDMSG_ADDBLEND;
	else if (ACSUtils_Ints[25] != 1.0)
		type |= HUDMSG_ALPHA;

	fixed x = ACSUtils_Ints[41];
	fixed y = ACSUtils_Ints[18];
	fixed iScaleX = ACSUtils_Ints[30];
	fixed iScaleY = ACSUtils_Ints[51];
	
	if (ACSUtils_Ints[52])
	{
		ACSUtils_HudRotate3DPoint();

		// Check if point is behind the camera.
		if (ACSUtils_Ints[14] <= 0)
		{
			ClearHudMessage(id);
			return;
		}
			
		// I don't know what this factor means, but it fixes positioning bugs.
		fixed yFactor = 1.6;
		if (StatusBarVisible())
			yFactor = 1.9;

		// Half heights.
		fixed hw = (fixed)((int)(ACSUtils_Ints[23]) / 2);
		fixed hh = (fixed)((int)(ACSUtils_Ints[46]) / 2);

		// Project point.
		x = -FixedDiv(ACSUtils_Ints[44], ACSUtils_Ints[14]);
		y = -FixedDiv(ACSUtils_Ints[22], ACSUtils_Ints[14]);
		
		if (ACSUtils_IsYShearing())
			y += tan(ACSUtils_Ints[11]);
		
		// Postprocess projected point.
		x += ACSUtils_Ints[12] + hw + FixedMul(hw, x);
		y += ACSUtils_Ints[21] + hh + FixedMul(FixedMul(hh, yFactor), y);
		
		if (ACSUtils_Ints[42])
		{
			iScaleX = FixedMul(iScaleX, ACSUtils_Ints[14] / CAMERA_BASE_DISTANCE);
			iScaleY = FixedMul(iScaleY, ACSUtils_Ints[14] / CAMERA_BASE_DISTANCE);
		}
	}
	
	fixed w = FixedMul(ACSUtils_Ints[23], iScaleX);
	fixed h = FixedMul(ACSUtils_Ints[46], iScaleY);
	SetHudSize(itrunc(w), itrunc(h), !(ACSUtils_Ints[52] || ACSUtils_Ints[45]));
	
	x = trunc(FixedMul(x, iScaleX));
	y = trunc(FixedMul(y, iScaleY));
	
	if (ACSUtils_Ints[13] == HUD_ALIGN_LEFT)
		x += 0.1;
	else if (ACSUtils_Ints[13] == HUD_ALIGN_RIGHT)
		x += 0.2;
		
	if (ACSUtils_Ints[49] == HUD_ALIGN_TOP)
		y += 0.1;
	else if (ACSUtils_Ints[49] == HUD_ALIGN_BOTTOM)
		y += 0.2;
		
	if (ACSUtils_Ints[26])
		x += 0.4;
	
	// BUG: this really simplifies the code, but the messages will only stay
	// for 9 hours.
	fixed stayTime = ACSUtils_Ints[6];
	if (stayTime < 0.0)
		stayTime = FIXED_MAX;
	
	if (ACSUtils_Ints[37])
	{
		HudMessageBold(s:text;
			type,
			id,
			ACSUtils_Ints[3],
			x, y,
			stayTime, ACSUtils_Ints[5], ACSUtils_Ints[48],
			ACSUtils_Ints[25]
		);
	}
	else
	{
		HudMessage(s:text;
			type,
			id,
			ACSUtils_Ints[3],
			x, y,
			stayTime, ACSUtils_Ints[5], ACSUtils_Ints[48],
			ACSUtils_Ints[25]
		);
	}
}

function void HudDrawText(int id, str text)
{
	int type = HUDMSG_FADEINOUT;
	if (ACSUtils_Ints[5] > 0 && ACSUtils_Ints[54])
		type = HUDMSG_TYPEON;
	
	if (ACSUtils_Ints[33])
		type |= HUDMSG_LOG;
	if (ACSUtils_Ints[1])
		type |= HUDMSG_COLORSTRING;
	if (!ACSUtils_Ints[10])
		type |= HUDMSG_NOWRAP;

	SetFont(ACSUtils_Strings[0]);
	ACSUtils_HudDrawHudMessage(id, type, text, true);
}

function void HudDrawImage(int id, str image)
{
	SetFont(image);
	ACSUtils_HudDrawHudMessage(id, HUDMSG_FADEINOUT, "A", false);
}

} // strict namespace BCSUtils
